<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <script src="assets/tailwindcss.js"></script>
</head>

<body class="bg-gray-100 font-sans">
    <div id="app"></div>

    <script src="assets/vendor-bundle.umd.js"></script>
    <script src="assets/babel.min.js"></script>
    <script type="text/babel">

        // ===================================================================
        // ===================     FRAMEWORK CODE     ========================
        // ===================================================================
        // This section contains the reusable, application-agnostic core.
        // You should not need to modify this section to add new features.
        // -------------------------------------------------------------------

        // 等价于
        // import * as React from 'react';
        // import ReactDOM from 'react-dom/client';
        // import * as redi from '@wendellhu/redi';
        // import * as rediReact from '@wendellhu/redi/react-bindings';
        // import * as rxjs from 'rxjs';
        // import * as reactSpring from '@react-spring/web';
        const { React, ReactDOM, redi, rediReact, rxjs, reactSpring } = globalThis.__tmp;
        delete globalThis.__tmp;

        // keep unused import for redi and rediReact
        const {
            Inject,
            Injector,
            LookUp,
            Many,
            Optional,
            Quantity,
            RediError,
            Self,
            SkipSelf,
            WithNew,
            createIdentifier,
            forwardRef,
            isAsyncDependencyItem,
            isAsyncHook,
            isClassDependencyItem,
            isCtor,
            isDisposable,
            isFactoryDependencyItem,
            isValueDependencyItem,
            setDependencies,
        } = redi;
        const {
            RediConsumer,
            RediContext,
            RediProvider,
            WithDependency,
            connectDependencies,
            connectInjector,
            useDependency,
            useInjector,
            useObservable,
            useUpdateBinder,
        } = rediReact;
        const {
            useState,
            useEffect,
            useRef,
            useReducer,
            Fragment,
            useCallback,
            createContext,
            useContext,
        } = React;
        const { BehaviorSubject } = rxjs;
        const { useSpring, useTransition, animated } = reactSpring;

        // 1. FRAMEWORK: CORE COMMUNICATION SERVICES

        const IBackendEventService = createIdentifier("IBackendEventService");
        class BackendEventService {
            constructor() {
                this.subscribers = new Map();
            }

            subscribe(eventType, callback) {
                if (!this.subscribers.has(eventType)) {
                    this.subscribers.set(eventType, new Set());
                }
                this.subscribers.get(eventType).add(callback);
                return () => {
                    const eventSubscribers = this.subscribers.get(eventType);
                    if (eventSubscribers) {
                        eventSubscribers.delete(callback);
                    }
                };
            }

            publish(eventType, data) {
                const eventSubscribers = this.subscribers.get(eventType);
                if (eventSubscribers) {
                    eventSubscribers.forEach((callback) => callback(data));
                }
            }
        }
        setDependencies(BackendEventService, []);

        const IMessageService = createIdentifier("IMessageService");
        class BrowserMessageService {
            constructor(eventService) {
                this.eventService = eventService;
                this.requestId = 0;
                this.handleBackendResponse = this.handleBackendResponse.bind(this);
                this.initializeListener();
            }
            async call(type, payload) {
                const correlationId = `req-${this.requestId++}`;
                const command = { type, payload, correlationId, timestamp: new Date().toISOString() };
                window.parent.sendMessage("frontend:message", command);
                return correlationId;
            }
            initializeListener() {
                window.addEventListener("message", this.handleBackendResponse);
            }
            handleBackendResponse(event) {
                if (event.data && event.data.type === "backendResponse") {
                    try {
                        const response = JSON.parse(event.data.data);
                        this.eventService.publish("backendResponse", response);
                    } catch (e) {
                        console.error("Fatal error parsing backend response:", e, event.data.data);
                    }
                }
            }
            dispose() {
                window.removeEventListener("message", this.handleBackendResponse);
            }
        }
        setDependencies(BrowserMessageService, [IBackendEventService]);

        // 2. FRAMEWORK: HIGH-LEVEL COMMAND ABSTRACTION

        const ICommandService = createIdentifier("ICommandService");
        class CommandService {
            constructor(messageService, eventService) {
                this.messageService = messageService;
                this.pendingCommands = new Map();
                this.RPC_TIMEOUT = 10000;
                this.handleBackendResponse = this.handleBackendResponse.bind(this);
                eventService.subscribe("backendResponse", this.handleBackendResponse);
            }

            execute = (type, payload) => {
                return new Promise(async (resolve, reject) => {
                    const commandId = await this.messageService.call(type, payload);
                    const timeoutId = setTimeout(() => {
                        if (this.pendingCommands.has(commandId)) {
                            this.pendingCommands.delete(commandId);
                            reject(new Error(`Command '${type}' timed out.`));
                        }
                    }, this.RPC_TIMEOUT);
                    this.pendingCommands.set(commandId, { resolve, reject, timeoutId, type });
                });
            };

            handleBackendResponse(response) {
                const { correlationId, taskId } = response;
                if (correlationId && this.pendingCommands.has(correlationId)) {
                    // Sync RPC or Async Task Initiation
                    const cmd = this.pendingCommands.get(correlationId);
                    if (response.status === "success") {
                        if (response.data && response.data.taskId) {
                            // It's an async task starting. Transfer promise to the new taskId.
                            const newTaskId = response.data.taskId;
                            this.pendingCommands.delete(correlationId); // remove old correlationId
                            this.pendingCommands.set(newTaskId, cmd); // re-map with taskId
                        } else {
                            // It's a normal sync RPC response.
                            clearTimeout(cmd.timeoutId);
                            this.pendingCommands.delete(correlationId);
                            cmd.resolve(response.data);
                        }
                    } else {
                        // Error on initiation
                        clearTimeout(cmd.timeoutId);
                        this.pendingCommands.delete(correlationId);
                        cmd.reject(new Error(response.message || "An unknown backend error occurred."));
                    }
                } else if (taskId && this.pendingCommands.has(taskId)) {
                    // Async Task Completion
                    const cmd = this.pendingCommands.get(taskId);
                    clearTimeout(cmd.timeoutId); // In case we want a total task timeout
                    this.pendingCommands.delete(taskId);

                    if (response.status === "success") {
                        cmd.resolve(response.data);
                    } else {
                        cmd.reject(new Error(response.message || "Async task failed."));
                    }
                }
            }
        }
        setDependencies(CommandService, [IMessageService, IBackendEventService]);

        // 3. FRAMEWORK: UNIFIED REACT HOOK FOR UI COMPONENTS

        const useCommand = () => {
            const commandService = useDependency(ICommandService);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [data, setData] = useState(null);

            const execute = useCallback(async (type, payload) => {
                setIsLoading(true);
                setError(null);
                setData(null);
                try {
                    const result = await commandService.execute(type, payload);
                    setData(result);
                    return result;
                } catch (err) {
                    setError(err.message);
                    throw err;
                } finally {
                    setIsLoading(false);
                }
            }, [commandService]);

            return { execute, isLoading, error, data };
        };

        // 4. FRAMEWORK: BOOTSTRAPPING AND VIEW MANAGEMENT

        // ===================================================================
        // ================== NEW FRAMEWORK EXTENSIONS =======================
        // ===================================================================
        // 1. NEW: Frontend Event Bus Service
        const IEventBus = createIdentifier("IEventBus");
        // Using the same implementation as BackendEventService for simplicity
        class EventBusService extends BackendEventService { }
        setDependencies(EventBusService, []);

        // 2. REFACTORED: Panel Service powered by RxJS
        const IPanel = createIdentifier("IPanel");
        const IPanelService = createIdentifier("IPanelService");
        class PanelService {
            constructor(panels) {
                this.allPanels = new Map(panels.map(p => [p.id, p]));

                // Internal state managed by a BehaviorSubject
                this._state$ = new BehaviorSubject(this.getInitialState());

                // Publicly exposed observable stream of the state
                this.state$ = this._state$.asObservable();
            }

            getInitialState() {
                const initialOpenIds = new Set(
                    Array.from(this.allPanels.values())
                        .filter(p => p.defaultActive)
                        .map(p => p.id)
                );
                const initialActiveId = Array.from(this.allPanels.values())
                    .find(p => p.defaultActive)?.id || null;
                return this._computeState(initialOpenIds, initialActiveId);
            }

            // Private method to compute the full state object from IDs
            _computeState(openPanelIds, activePanelId) {
                const openPanels = Array.from(openPanelIds)
                    .map(id => this.allPanels.get(id))
                    .filter(Boolean); // Filter out potential undefineds
                const activePanel = activePanelId ? this.allPanels.get(activePanelId) : null;

                return { openPanels, activePanel };
            }

            // Private method to update the stream
            _updateState(newOpenIds, newActiveId) {
                const newState = this._computeState(newOpenIds, newActiveId);
                this._state$.next(newState);
            }

            // --- Public API for Panel Control ---
            openPanel(id) {
                if (!this.allPanels.has(id)) return;

                const currentState = this._state$.getValue();
                const currentOpenIds = new Set(currentState.openPanels.map(p => p.id));

                if (currentOpenIds.has(id)) {
                    this.setActivePanel(id);
                    return;
                }

                currentOpenIds.add(id);
                this._updateState(currentOpenIds, id);
            }

            closePanel(id) {
                const currentState = this._state$.getValue();
                const currentOpenIds = new Set(currentState.openPanels.map(p => p.id));
                if (!currentOpenIds.has(id)) return;

                currentOpenIds.delete(id);
                let newActiveId = currentState.activePanel?.id;
                if (newActiveId === id) {
                    newActiveId = currentOpenIds.values().next().value || null;
                }
                this._updateState(currentOpenIds, newActiveId);
            }

            setActivePanel(id) {
                const currentState = this._state$.getValue();
                if (currentState.activePanel?.id === id) return;

                const currentOpenIds = new Set(currentState.openPanels.map(p => p.id));
                if (!currentOpenIds.has(id)) return; // Can't activate a panel that isn't open

                this._updateState(currentOpenIds, id);
            }
        }
        setDependencies(PanelService, [[new Many(), IPanel]]);

        // 3. REFACTORED: The App Shell Component, now a pure projection of state
        const AppShell = () => {
            const panelService = useDependency(IPanelService);

            // Subscribe to the state stream.
            const { openPanels, activePanel } = useObservable(
                panelService.state$,
                panelService.getInitialState()
            );

            // Setup transitions for the active panel
            const panelTransitions = useTransition(activePanel, {
                key: panel => panel?.id,
                from: { opacity: 0, transform: 'translateY(10px)' },
                enter: { opacity: 1, transform: 'translateY(0px)' },
                leave: { opacity: 0, transform: 'translateY(-10px)', position: 'absolute', top: 0, left: 0, right: 0 },
                config: { tension: 220, friction: 25 },
            });

            return (
                <div className="p-4 max-w-5xl mx-auto bg-gray-50 shadow-lg rounded-lg mt-8 flex flex-col h-[90vh]">
                    <h1 className="text-3xl font-bold text-gray-800 mb-4 text-center">
                        Mendix Portal Control Panel (RxJS)
                    </h1>
                    <div className="flex border-b border-gray-300">
                        {openPanels.map(panel => (
                            <button
                                key={panel.id}
                                onClick={() => panelService.setActivePanel(panel.id)}
                                className={`px-4 py-2 text-sm font-medium border-b-2 ${panel.id === activePanel?.id ? 'border-purple-600 text-purple-700' : 'border-transparent text-gray-500 hover:text-gray-700'}`}
                            >
                                {panel.title}
                            </button>
                        ))}
                    </div>
                    <div className="flex-grow p-4 bg-white relative overflow-hidden">
                        {panelTransitions((style, panel) =>
                            panel ? (
                                <animated.div style={style} className="w-full h-full">
                                    <panel.component />
                                </animated.div>
                            ) : (
                                <div className="text-center text-gray-500">No panel selected.</div>
                            )
                        )}
                    </div>
                </div>
            );
        };

        const Alert = ({ message, type, style }) => {
            const baseClasses = "text-sm px-4 py-2 rounded-md";
            const typeClasses = {
                success: "bg-green-100 text-green-800",
                error: "bg-red-100 text-red-800",
            };
            return <animated.div style={style} className={`${baseClasses} ${typeClasses[type]}`}>{message}</animated.div>;
        };


        // ===================================================================
        // ===============     BUSINESS LOGIC CODE     =======================
        // ===================================================================
        // This section contains your feature-specific components (Views).
        // To add a new feature, add your new Component here and register
        // it as an `IView` in the IOC Configuration section below.
        // -------------------------------------------------------------------

        const SimulateTaskPanel = () => {
            const [seconds, setSeconds] = useState(5);
            const { execute, isLoading, error, data } = useCommand();
            const eventBus = useDependency(IEventBus);
            const panelService = useDependency(IPanelService);

            const handleStartTask = async () => {
                const duration = parseInt(seconds, 10);
                if (isNaN(duration) || duration <= 0) return;

                eventBus.publish("task:started", { duration });
                panelService.openPanel('logger');

                try {
                    const result = await execute("SIMULATE_TASK", { seconds: duration });
                    eventBus.publish("task:completed", { status: 'success', result });
                } catch (err) {
                    eventBus.publish("task:completed", { status: 'error', error: err.message });
                }
            };

            const alertItem = error
                ? { key: 'error', type: 'error', message: error }
                : data && !isLoading
                    ? { key: 'success', type: 'success', message: data.message }
                    : null;

            const alertTransitions = useTransition(alertItem, {
                from: { opacity: 0, transform: 'translateY(-10px)' },
                enter: { opacity: 1, transform: 'translateY(0px)' },
                leave: { opacity: 0, transform: 'translateY(-10px)', position: 'absolute', top: 0, left: 0, right: 0 },
            });

            return (
                <div>
                    <h2 className="text-xl font-semibold text-gray-700 mb-4">
                        Unified Task Runner
                    </h2>
                    <p className="text-sm text-gray-600 mb-4">
                        This panel can run backend tasks and communicate with other panels via the Event Bus.
                    </p>
                    <div className="flex items-center space-x-3 p-4 bg-white border border-gray-200 rounded-lg">
                        <input type="number" value={seconds} onChange={(e) => setSeconds(e.target.value)} className="w-24 px-3 py-2 border border-gray-300 rounded-md" disabled={isLoading} />
                        <button onClick={handleStartTask} disabled={isLoading} className="px-4 py-2 bg-purple-600 text-white font-semibold rounded-md hover:bg-purple-700 disabled:bg-purple-300 disabled:cursor-not-allowed w-48 text-center">
                            {isLoading ? `Running (${seconds}s)...` : "Start Task & Open Logger"}
                        </button>
                    </div>
                    <div className="mt-3 h-8 relative">
                        {alertTransitions((style, item) =>
                            item ? <Alert style={style} message={item.message} type={item.type} /> : null
                        )}
                    </div>
                </div>
            );
        };
        // Panel 2: A logger that listens to events from other panels
        const LoggerPanel = () => {
            const eventBus = useDependency(IEventBus);
            const [logs, setLogs] = useState([]);

            useEffect(() => {
                const addLog = (logEntry) => {
                    const timestamp = new Date().toLocaleTimeString();
                    const uniqueKey = `${Date.now()}-${Math.random()}`; // For stable transition keys
                    setLogs(prev => [...prev, { ...logEntry, timestamp, key: uniqueKey }]);
                };

                const subscriptions = [
                    eventBus.subscribe("task:started", (data) => addLog({ type: "info", message: `Task started. Duration: ${data.duration}s` })),
                    eventBus.subscribe("task:completed", (data) => {
                        if (data.status === 'success') {
                            addLog({ type: "success", message: `Task completed successfully: ${data.result.message}` });
                        } else {
                            addLog({ type: "error", message: `Task failed: ${data.error}` });
                        }
                    }),
                ];

                return () => subscriptions.forEach(unsubscribe => unsubscribe());
            }, [eventBus]);

            const logTransitions = useTransition(logs, {
                from: { opacity: 0, transform: 'translateY(10px)' },
                enter: { opacity: 1, transform: 'translateY(0px)' },
                keys: item => item.key,
            });

            return (
                <div>
                    <h2 className="text-xl font-semibold text-gray-700 mb-4">Event Log</h2>
                    <div className="space-y-2 p-3 bg-gray-800 text-white font-mono text-xs rounded-md h-64 overflow-y-auto">
                        {logTransitions((style, log) => (
                            <animated.p
                                style={style}
                                className={log.type === 'error' ? 'text-red-400' : log.type === 'success' ? 'text-green-400' : 'text-gray-300'}
                            >
                                [{log.timestamp}] {log.message}
                            </animated.p>
                        ))}
                    </div>
                </div>
            );
        };

        // ===================================================================
        // ==============     IOC & APP INITIALIZATION     ===================
        // ===================================================================

        const AppWithDependencies = connectDependencies(AppShell, [
            // --- Framework Registrations ---
            [IBackendEventService, { useClass: BackendEventService }],
            [IMessageService, { useClass: BrowserMessageService }],
            [ICommandService, { useClass: CommandService }],
            [IEventBus, { useClass: EventBusService }],
            [IPanelService, { useClass: PanelService }],

            // --- Business Logic Registrations (as Panels) ---
            [IPanel, { useValue: { id: 'task-runner', title: 'Task Runner', component: SimulateTaskPanel, defaultActive: true } }],
            [IPanel, { useValue: { id: 'logger', title: 'Event Logger', component: LoggerPanel, defaultActive: true } }],
        ]);

        const root = ReactDOM.createRoot(document.getElementById("app"));
        root.render(<AppWithDependencies />);
    </script>
</body>

</html>