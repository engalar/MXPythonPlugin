<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <script src="assets/tailwindcss.js"></script>
</head>

<body class="bg-gray-100 font-sans">
    <div id="app"></div>

    <script src="assets/vendor-bundle.umd.js"></script>
    <script src="assets/babel.min.js"></script>
    <script type="text/babel">
        const { React, ReactDOM, redi, rediReact } = globalThis.__tmp;
        delete globalThis.__tmp;

        // keep unused import for redi and rediReact
        const {
            Inject,
            Injector,
            LookUp,
            Many,
            Optional,
            Quantity,
            RediError,
            Self,
            SkipSelf,
            WithNew,
            createIdentifier,
            forwardRef,
            isAsyncDependencyItem,
            isAsyncHook,
            isClassDependencyItem,
            isCtor,
            isDisposable,
            isFactoryDependencyItem,
            isValueDependencyItem,
            setDependencies,
        } = redi;
        const {
            RediConsumer,
            RediContext,
            RediProvider,
            WithDependency,
            connectDependencies,
            connectInjector,
            useDependency,
            useInjector,
            useObservable,
            useUpdateBinder,
        } = rediReact;
        const { useState, useEffect, useReducer, Fragment, useCallback, createContext, useContext } = React;

        // ===================================================================
        // 1. STATE & COMMUNICATION SERVICES
        // ===================================================================

        const IMessageService = createIdentifier("IMessageService");
        class BrowserMessageService {
            constructor() {
                this.requestId = 0;
                this.pendingRequests = new Map();
                this.initializeListener();
                this.RPC_TIMEOUT = 10000;
            }
            async call(type, payload) {
                const correlationId = `req-${this.requestId++}`;
                const command = { type, payload, correlationId, timestamp: new Date().toISOString() };
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        if (this.pendingRequests.has(correlationId)) {
                            this.pendingRequests.delete(correlationId);
                            reject(new Error(`RPC call timed out for type '${type}'`));
                        }
                    }, this.RPC_TIMEOUT);
                    this.pendingRequests.set(correlationId, { resolve, reject, timeoutId });
                    window.parent.sendMessage("frontend:message", command);
                });
            }
            initializeListener() {
                window.addEventListener("message", this.handleBackendResponse);
            }
            handleBackendResponse = (event) => {
                if (!(event.data && event.data.type === "backendResponse")) return;
                try {
                    const response = JSON.parse(event.data.data);
                    const { correlationId } = response;
                    if (!correlationId || !this.pendingRequests.has(correlationId)) return;
                    const { resolve, reject, timeoutId } = this.pendingRequests.get(correlationId);
                    clearTimeout(timeoutId);
                    this.pendingRequests.delete(correlationId);
                    if (response.status === "success") {
                        resolve(response.data);
                    } else {
                        reject(new Error(response.message || "An unknown backend error occurred."));
                    }
                } catch (e) {
                    console.error("Fatal error parsing backend response:", e, event.data.data);
                }
            };
            dispose() {
                window.removeEventListener("message", this.handleBackendResponse);
            }
        }
        setDependencies(BrowserMessageService, []);

        const IView = createIdentifier("IView");
        class ViewManagementService {
            constructor(views) { this.views = views; }
            getViews() { return this.views; }
        }
        setDependencies(ViewManagementService, [[new Many(), IView]]);

        // ===================================================================
        // 2. REUSABLE HOOKS (Centralized stateful logic)
        // ===================================================================

        const useRpc = () => {
            const messageService = useDependency(IMessageService);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [data, setData] = useState(null);

            const execute = useCallback(
                async (type, payload) => {
                    setIsLoading(true);
                    setError(null);
                    setData(null);
                    try {
                        const result = await messageService.call(type, payload);
                        setData(result);
                        return result;
                    } catch (err) {
                        setError(err.message);
                        throw err;
                    } finally {
                        setIsLoading(false);
                    }
                },
                [messageService]
            );
            return { execute, isLoading, error, data, setData };
        };

        // --- START: New Component for Simulating Long Tasks ---
        const SimulateTaskView = () => {
            const [seconds, setSeconds] = useState(5);
            const { execute, isLoading, error, data, setData } = useRpc();

            const handleStartTask = async () => {
                const duration = parseInt(seconds, 10);
                if (isNaN(duration) || duration <= 0) {
                    // Simple validation feedback
                    setData(null); // Clear previous success messages
                    return;
                }
                // The `execute` call will handle setting loading/error states
                await execute("SIMULATE_TASK", { seconds: duration }).catch(() => { });
            };

            return (
                <div className="border-t border-gray-300 mt-6 pt-6">
                    <h2 className="text-xl font-semibold text-gray-700 mb-4">Task Simulation (Test Case)</h2>
                    <p className="text-sm text-gray-600 mb-4">
                        This tool simulates a long-running backend task to test the UI's responsiveness.
                        The UI should appear blocked while the task is running.
                    </p>
                    <div className="flex items-center space-x-3 p-4 bg-white border border-gray-200 rounded-lg">
                        <label htmlFor="duration" className="font-medium text-gray-700">Duration (s):</label>
                        <input
                            id="duration"
                            type="number"
                            value={seconds}
                            onChange={(e) => setSeconds(e.target.value)}
                            className="w-24 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                            disabled={isLoading}
                            min="1"
                            max="60"
                        />
                        <button
                            onClick={handleStartTask}
                            disabled={isLoading}
                            className="px-4 py-2 bg-purple-600 text-white font-semibold rounded-md hover:bg-purple-700 disabled:bg-purple-300 disabled:cursor-not-allowed"
                        >
                            {isLoading ? `Running for ${seconds}s...` : 'Start Blocking Task'}
                        </button>
                    </div>
                    <div className="mt-3 h-6">
                        {error && <Alert message={error} type="error" />}
                        {data && !isLoading && <Alert message={data.message} type="success" />}
                    </div>
                </div>
            );
        };
        // --- END: New Component for Simulating Long Tasks ---
        // ===================================================================
        // 5. MAIN APP & IOC CONFIGURATION (No changes needed)
        // ===================================================================
        const App = () => {
            const viewManager = useDependency(ViewManagementService);
            return (
                <div className="p-4 max-w-4xl mx-auto bg-gray-50 shadow-lg rounded-lg mt-8">
                    <h1 className="text-3xl font-bold text-gray-800 mb-6 text-center">
                        Mendix Backend Control Panel
                    </h1>
                    {viewManager.getViews().map((ViewComponent, index) => (
                        <Fragment key={index}>
                            <ViewComponent />
                        </Fragment>
                    ))}
                </div>
            );
        };

        const AppWithDependencies = connectDependencies(App, [
            [ViewManagementService],
            [IMessageService, { useClass: BrowserMessageService }],
            [IView, { useValue: SimulateTaskView }], // Uses the new, clean view
        ]);

        const root = ReactDOM.createRoot(document.getElementById("app"));
        root.render(<AppWithDependencies />);
    </script>
</body>

</html>