<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <script src="assets/tailwindcss.js"></script>
</head>

<body class="bg-gray-100 font-sans">
    <div id="app"></div>

    <script src="assets/vendor-bundle.umd.js"></script>
    <script src="assets/babel.min.js"></script>
    <script type="text/babel">
        const { React, ReactDOM, redi, rediReact } = globalThis.__tmp;
        delete globalThis.__tmp;

        // keep unused import for redi and rediReact
        const { Inject, Injector, LookUp, Many, Optional, Quantity, RediError, Self, SkipSelf, WithNew, createIdentifier, forwardRef, isAsyncDependencyItem, isAsyncHook, isClassDependencyItem, isCtor, isDisposable, isFactoryDependencyItem, isValueDependencyItem, setDependencies } = redi;
        const { RediConsumer, RediContext, RediProvider, WithDependency, connectDependencies, connectInjector, useDependency, useInjector, useObservable, useUpdateBinder } = rediReact;
        const { useState, useEffect, useReducer, Fragment, useCallback } = React;

        // ===================================================================
        // 1. STATE & COMMUNICATION SERVICES
        // ===================================================================

        // 1.2. COMMUNICATION SERVICE (REFACTORED for RPC)
        const IMessageService = createIdentifier('IMessageService');
        class BrowserMessageService {
            constructor() {
                this.requestId = 0;
                this.pendingRequests = new Map();
                this.initializeListener();
                this.RPC_TIMEOUT = 10000; // 10 seconds
            }

            // The core RPC 'call' method
            async call(type, payload) {
                const correlationId = `req-${this.requestId++}`;
                const command = { type, payload, correlationId, timestamp: new Date().toISOString() };

                return new Promise((resolve, reject) => {
                    // Set a timeout for the request
                    const timeoutId = setTimeout(() => {
                        if (this.pendingRequests.has(correlationId)) {
                            this.pendingRequests.delete(correlationId);
                            const error = new Error(`RPC call timed out for type '${type}'`);
                            reject(error);
                        }
                    }, this.RPC_TIMEOUT);

                    // Store the promise handlers
                    this.pendingRequests.set(correlationId, { resolve, reject, timeoutId });

                    // Send the command to the backend
                    window.parent.sendMessage("frontend:message", command);
                });
            }

            initializeListener() { window.addEventListener('message', this.handleBackendResponse); }

            handleBackendResponse = (event) => {
                if (!(event.data && event.data.type === 'backendResponse')) return;
                try {
                    const response = JSON.parse(event.data.data);
                    const { correlationId } = response;

                    if (!correlationId || !this.pendingRequests.has(correlationId)) {
                        console.warn("Received response for an unknown or timed-out request:", response);
                        return;
                    }

                    const { resolve, reject, timeoutId } = this.pendingRequests.get(correlationId);
                    clearTimeout(timeoutId); // Clear the timeout
                    this.pendingRequests.delete(correlationId); // Clean up


                    if (response.status === 'success') {
                        resolve(response.data);
                    } else {
                        reject(new Error(response.message || 'An unknown backend error occurred.'));
                    }
                } catch (e) {
                    console.error("Fatal error parsing backend response:", e, event.data.data);
                }
            };
            dispose() { window.removeEventListener('message', this.handleBackendResponse); }
        }
        setDependencies(BrowserMessageService, []);


        // ===================================================================
        // 2. VIEW ABSTRACTION AND MANAGEMENT (Unchanged)
        // ===================================================================
        const IView = createIdentifier('IView');
        class ViewManagementService {
            constructor(views) { this.views = views; }
            getViews() { return this.views; }
        }
        setDependencies(ViewManagementService, [[new Many, IView]]);


        // ===================================================================
        // 3. UI COMPONENTS (ADAPTED for Async/Await and RPC)
        // ===================================================================

        // Reusable hook for handling RPC calls in components
        const useRpc = () => {
            const messageService = useDependency(IMessageService);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [data, setData] = useState(null);

            const execute = useCallback(async (type, payload) => {
                setIsLoading(true);
                setError(null);
                setData(null);
                try {
                    const result = await messageService.call(type, payload);
                    setData(result);
                    return result;
                } catch (err) {
                    setError(err.message);
                    // allow component to handle the error too
                    throw err;
                } finally {
                    setIsLoading(false);
                }
            }, [messageService]);

            return { execute, isLoading, error, data };
        };

        // --- START: New MCP Control Component ---
        const McpControlView = () => {
            const [serverState, setServerState] = useState({ status: 'unknown', port: null, tools: [] });
            const { execute: executeControl, isLoading: isControlLoading, error: controlError } = useRpc();
            const { execute: executeQuery, isLoading: isQueryLoading, error: queryError } = useRpc();

            const isRunning = serverState.status === 'running';
            const isLoading = isControlLoading || isQueryLoading;

            const fetchStatus = useCallback(async () => {
                try {
                    const statusData = await executeQuery('MCP_CONTROL', { action: 'get_status' });
                    const toolsData = statusData.status === 'running'
                        ? await executeQuery('MCP_CONTROL', { action: 'list_tools' })
                        : { tools: [] };
                    setServerState({ ...statusData, tools: toolsData.tools });
                } catch (e) {
                    console.error("Failed to fetch MCP status:", e);
                    setServerState({ status: 'error', port: null, tools: [] });
                }
            }, [executeQuery]);

            useEffect(() => {
                fetchStatus();
            }, [fetchStatus]);

            const handleStart = async () => {
                try {
                    await executeControl('MCP_CONTROL', { action: 'start' });
                    await fetchStatus();
                } catch (e) { console.error("Failed to start MCP server:", e); }
            };

            const handleStop = async () => {
                try {
                    await executeControl('MCP_CONTROL', { action: 'stop' });
                    // Give server a moment to shut down before fetching status
                    setTimeout(fetchStatus, 500);
                } catch (e) { console.error("Failed to stop MCP server:", e); }
            };

            const statusColor = isRunning ? 'bg-green-500' : (serverState.status === 'stopped' ? 'bg-red-500' : 'bg-yellow-500');
            const statusText = isRunning ? `Running on port ${serverState.port}` : (serverState.status === 'stopped' ? 'Stopped' : 'Unknown');

            return (
                <div className="p-4 border-b border-gray-200">
                    <h2 className="text-xl font-semibold text-gray-700 mb-2">MCP Server Control</h2>
                    <div className="flex items-center space-x-4 mb-4">
                        <div className="flex items-center space-x-2">
                            <span className={`w-3 h-3 rounded-full ${statusColor}`}></span>
                            <span className="font-medium text-gray-800">{statusText}</span>
                        </div>
                        <button onClick={fetchStatus} disabled={isLoading} className="px-3 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300 disabled:opacity-50">
                            {isQueryLoading ? 'Refreshing...' : 'Refresh'}
                        </button>
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                        <button onClick={handleStart} disabled={isLoading || isRunning} className="w-full px-6 py-3 bg-blue-600 text-white rounded-md font-semibold hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                            {isControlLoading ? 'Starting...' : 'Start Server'}
                        </button>
                        <button onClick={handleStop} disabled={isLoading || !isRunning} className="w-full px-6 py-3 bg-red-600 text-white rounded-md font-semibold hover:bg-red-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                            {isControlLoading ? 'Stopping...' : 'Stop Server'}
                        </button>
                    </div>
                    {(controlError || queryError) && <p className="text-red-600 mt-2 text-sm">{controlError || queryError}</p>}

                    {isRunning && serverState.tools.length > 0 && (
                        <div className="mt-4">
                            <h3 className="text-lg font-semibold text-gray-600 mb-2">Available Tools:</h3>
                            <ul className="list-disc list-inside bg-gray-50 p-3 rounded border">
                                {serverState.tools.map(tool => (
                                    <li key={tool.name} className="text-gray-700">
                                        <strong className="font-mono">{tool.name}</strong>: {tool.description}
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                </div>
            );
        };
        // --- END: New MCP Control Component ---

        // ===================================================================
        // 4. MAIN APP & IOC CONFIGURATION
        // ===================================================================
        const App = () => {
            const viewManager = useDependency(ViewManagementService);
            return (
                <div className="p-4 max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-8">
                    <h1 className="text-3xl font-bold text-gray-800 mb-6 text-center">Mendix Backend Control Panel (RPC)</h1>
                    {viewManager.getViews().map((ViewComponent, index) => <Fragment key={index}><ViewComponent /></Fragment>)}
                </div>
            );
        };

        const AppWithDependencies = connectDependencies(App, [
            [ViewManagementService],
            [IMessageService, { useClass: BrowserMessageService }],
            // Add the new MCP control view here
            [IView, { useValue: McpControlView }],
        ]);

        const root = ReactDOM.createRoot(document.getElementById('app'));
        root.render(<AppWithDependencies />);
    </script>
</body>

</html>