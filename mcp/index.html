<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <script src="assets/tailwindcss.js"></script>
</head>

<body class="bg-gray-100 font-sans">
    <div id="app"></div>

    <script src="assets/vendor-bundle.umd.js"></script>
    <script src="assets/babel.min.js"></script>
    <script type="text/babel">

        // ===================================================================
        // ===================     FRAMEWORK CODE     ========================
        // ===================================================================
        // This section contains the reusable, application-agnostic core.
        // You should not need to modify this section to add new features.
        // -------------------------------------------------------------------
 
        // 等价于
        // import * as React from 'react';
        // import ReactDOM from 'react-dom/client';
        // import * as redi from '@wendellhu/redi';
        // import * as rediReact from '@wendellhu/redi/react-bindings';
        // import * as rxjs from 'rxjs';
        // import * as reactSpring from '@react-spring/web';
        const { React, ReactDOM, redi, rediReact, rxjs, reactSpring } = globalThis.__tmp;
        delete globalThis.__tmp;

        // keep unused import for redi and rediReact
        const {
            Inject,
            Injector,
            LookUp,
            Many,
            Optional,
            Quantity,
            RediError,
            Self,
            SkipSelf,
            WithNew,
            createIdentifier,
            forwardRef,
            isAsyncDependencyItem,
            isAsyncHook,
            isClassDependencyItem,
            isCtor,
            isDisposable,
            isFactoryDependencyItem,
            isValueDependencyItem,
            setDependencies,
        } = redi;
        const {
            RediConsumer,
            RediContext,
            RediProvider,
            WithDependency,
            connectDependencies,
            connectInjector,
            useDependency,
            useInjector,
            useObservable,
            useUpdateBinder,
        } = rediReact;
        const {
            useState,
            useEffect,
            useRef,
            useReducer,
            Fragment,
            useCallback,
            createContext,
            useContext,
        } = React;
        // 1. FRAMEWORK: CORE COMMUNICATION SERVICES

        const IBackendEventService = createIdentifier("IBackendEventService");
        class BackendEventService {
            constructor() {
                this.subscribers = new Map();
            }

            subscribe(eventType, callback) {
                if (!this.subscribers.has(eventType)) {
                    this.subscribers.set(eventType, new Set());
                }
                this.subscribers.get(eventType).add(callback);
                return () => {
                    const eventSubscribers = this.subscribers.get(eventType);
                    if (eventSubscribers) {
                        eventSubscribers.delete(callback);
                    }
                };
            }

            publish(eventType, data) {
                const eventSubscribers = this.subscribers.get(eventType);
                if (eventSubscribers) {
                    eventSubscribers.forEach((callback) => callback(data));
                }
            }
        }
        setDependencies(BackendEventService, []);

        const IMessageService = createIdentifier("IMessageService");
        class BrowserMessageService {
            constructor(eventService) {
                this.eventService = eventService;
                this.requestId = 0;
                this.handleBackendResponse = this.handleBackendResponse.bind(this);
                this.initializeListener();
            }
            async call(type, payload) {
                const correlationId = `req-${this.requestId++}`;
                const command = { type, payload, correlationId, timestamp: new Date().toISOString() };
                window.parent.sendMessage("frontend:message", command);
                return correlationId;
            }
            initializeListener() {
                window.addEventListener("message", this.handleBackendResponse);
            }
            handleBackendResponse(event) {
                if (event.data && event.data.type === "backendResponse") {
                    try {
                        const response = JSON.parse(event.data.data);
                        this.eventService.publish("backendResponse", response);
                    } catch (e) {
                        console.error("Fatal error parsing backend response:", e, event.data.data);
                    }
                }
            }
            dispose() {
                window.removeEventListener("message", this.handleBackendResponse);
            }
        }
        setDependencies(BrowserMessageService, [IBackendEventService]);

        // 2. FRAMEWORK: HIGH-LEVEL COMMAND ABSTRACTION

        const ICommandService = createIdentifier("ICommandService");
        class CommandService {
            constructor(messageService, eventService) {
                this.messageService = messageService;
                this.pendingCommands = new Map();
                this.RPC_TIMEOUT = 10000;
                this.handleBackendResponse = this.handleBackendResponse.bind(this);
                eventService.subscribe("backendResponse", this.handleBackendResponse);
            }

            execute = (type, payload) => {
                return new Promise(async (resolve, reject) => {
                    const commandId = await this.messageService.call(type, payload);
                    const timeoutId = setTimeout(() => {
                        if (this.pendingCommands.has(commandId)) {
                            this.pendingCommands.delete(commandId);
                            reject(new Error(`Command '${type}' timed out.`));
                        }
                    }, this.RPC_TIMEOUT);
                    this.pendingCommands.set(commandId, { resolve, reject, timeoutId, type });
                });
            };

            handleBackendResponse(response) {
                const { correlationId, taskId } = response;
                if (correlationId && this.pendingCommands.has(correlationId)) {
                    // Sync RPC or Async Task Initiation
                    const cmd = this.pendingCommands.get(correlationId);
                    if (response.status === "success") {
                        if (response.data && response.data.taskId) {
                            // It's an async task starting. Transfer promise to the new taskId.
                            const newTaskId = response.data.taskId;
                            this.pendingCommands.delete(correlationId); // remove old correlationId
                            this.pendingCommands.set(newTaskId, cmd); // re-map with taskId
                        } else {
                            // It's a normal sync RPC response.
                            clearTimeout(cmd.timeoutId);
                            this.pendingCommands.delete(correlationId);
                            cmd.resolve(response.data);
                        }
                    } else {
                        // Error on initiation
                        clearTimeout(cmd.timeoutId);
                        this.pendingCommands.delete(correlationId);
                        cmd.reject(new Error(response.message || "An unknown backend error occurred."));
                    }
                } else if (taskId && this.pendingCommands.has(taskId)) {
                    // Async Task Completion
                    const cmd = this.pendingCommands.get(taskId);
                    clearTimeout(cmd.timeoutId); // In case we want a total task timeout
                    this.pendingCommands.delete(taskId);

                    if (response.status === "success") {
                        cmd.resolve(response.data);
                    } else {
                        cmd.reject(new Error(response.message || "Async task failed."));
                    }
                }
            }
        }
        setDependencies(CommandService, [IMessageService, IBackendEventService]);

        // 3. FRAMEWORK: UNIFIED REACT HOOK FOR UI COMPONENTS

        const useCommand = () => {
            const commandService = useDependency(ICommandService);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [data, setData] = useState(null);

            const execute = useCallback(async (type, payload) => {
                setIsLoading(true);
                setError(null);
                setData(null);
                try {
                    const result = await commandService.execute(type, payload);
                    setData(result);
                    return result;
                } catch (err) {
                    setError(err.message);
                    throw err;
                } finally {
                    setIsLoading(false);
                }
            }, [commandService]);

            return { execute, isLoading, error, data };
        };

        // 4. FRAMEWORK: BOOTSTRAPPING AND VIEW MANAGEMENT

        const IView = createIdentifier("IView");
        class ViewManagementService {
            constructor(views) { this.views = views; }
            getViews() { return this.views; }
        }
        setDependencies(ViewManagementService, [[new Many(), IView]]);

        const App = () => {
            const viewManager = useDependency(ViewManagementService);
            return (
                <div className="p-4 max-w-5xl mx-auto bg-gray-50 shadow-lg rounded-lg flex flex-col h-[100vh]">
                    {viewManager.getViews().map((ViewComponent, index) => (
                        <Fragment key={index}><ViewComponent /></Fragment>
                    ))}
                </div>
            );
        };

        const Alert = ({ message, type }) => {
            const baseClasses = "text-sm px-4 py-2 rounded-md";
            const typeClasses = {
                success: "bg-green-100 text-green-800",
                error: "bg-red-100 text-red-800",
            };
            return <div className={`${baseClasses} ${typeClasses[type]}`}>{message}</div>;
        };


        // ===================================================================
        // ===============     BUSINESS LOGIC CODE     =======================
        // ===================================================================
        // This section contains your feature-specific components (Views).
        // To add a new feature, add your new Component here and register
        // it as an `IView` in the IOC Configuration section below.
        // -------------------------------------------------------------------

        const McpControlView = () => {
            const [serverState, setServerState] = useState({ status: 'unknown', port: null });
            const [tools, setTools] = useState([]);
            const { execute: executeControl, isLoading: isControlLoading, error: controlError } = useCommand();
            const { execute: executeQuery, isLoading: isQueryLoading, error: queryError } = useCommand();

            const isRunning = serverState.status === 'running';
            const isLoading = isControlLoading || isQueryLoading;

            const fetchStatusAndTools = useCallback(async () => {
                try {
                    const statusData = await executeQuery('MCP_GET_STATUS', {});
                    setServerState(statusData);
                    if (statusData.status === 'running') {
                        const toolsData = await executeQuery('MCP_LIST_TOOLS', {});
                        setTools(toolsData.tools || []);
                    } else {
                        setTools([]);
                    }
                } catch (e) {
                    console.error("Failed to fetch MCP status:", e);
                    setServerState({ status: 'error', port: null });
                }
            }, [executeQuery]);

            useEffect(() => { fetchStatusAndTools(); }, [fetchStatusAndTools]);

            const handleStart = async () => {
                try {
                    // The hook handles the async lifecycle. We just await the final result.
                    const finalState = await executeControl('MCP_START', {});
                    setServerState(finalState);
                    await fetchStatusAndTools(); // Refresh tools list
                } catch (e) { console.error("Failed to start MCP server:", e); fetchStatusAndTools(); }
            };

            const handleStop = async () => {
                try {
                    const finalState = await executeControl('MCP_STOP', {});
                    setServerState(finalState);
                    setTools([]);
                } catch (e) { console.error("Failed to stop MCP server:", e); fetchStatusAndTools(); }
            };

            // ... (JSX remains largely the same, but uses `tools` state variable)
            const statusColor = isRunning ? 'bg-green-500' : (serverState.status === 'stopped' ? 'bg-red-500' : 'bg-yellow-500');
            const statusText = isRunning ? `Running on port ${serverState.port}` : (serverState.status === 'stopped' ? 'Stopped' : 'Unknown');

            return (
                <div className="p-4 border-b border-gray-200">
                    <h2 className="text-xl font-semibold text-gray-700 mb-2">MCP Server Control</h2>
                    <div className="flex items-center space-x-4 mb-4">
                        <div className="flex items-center space-x-2">
                            <span className={`w-3 h-3 rounded-full ${statusColor}`}></span>
                            <span className="font-medium text-gray-800">{statusText}</span>
                        </div>
                        <button onClick={fetchStatusAndTools} disabled={isLoading} className="px-3 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300 disabled:opacity-50">
                            {isQueryLoading ? 'Refreshing...' : 'Refresh'}
                        </button>
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                        <button onClick={handleStart} disabled={isLoading || isRunning} className="w-full px-6 py-3 bg-blue-600 text-white rounded-md font-semibold hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                            {isControlLoading ? 'Starting...' : 'Start Server'}
                        </button>
                        <button onClick={handleStop} disabled={isLoading || !isRunning} className="w-full px-6 py-3 bg-red-600 text-white rounded-md font-semibold hover:bg-red-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                            {isControlLoading ? 'Stopping...' : 'Stop Server'}
                        </button>
                    </div>
                    {(controlError || queryError) && <p className="text-red-600 mt-2 text-sm">{controlError || queryError}</p>}

                    {isRunning && tools.length > 0 && (
                        <div className="mt-4">
                            <h3 className="text-lg font-semibold text-gray-600 mb-2">Available Tools:</h3>
                            <ul className="list-disc list-inside bg-gray-50 p-3 rounded border">
                                {tools.map(tool => (
                                    <li key={tool.name} className="text-gray-700">
                                        <strong className="font-mono">{tool.name}</strong>: {tool.description}
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                </div>
            );
        };// --- END: New MCP Control Component ---

        // ===================================================================
        // ==============     IOC & APP INITIALIZATION     ===================
        // ===================================================================

        const AppWithDependencies = connectDependencies(App, [
            // --- Framework Registrations ---
            [ViewManagementService],
            [IBackendEventService, { useClass: BackendEventService }],
            [IMessageService, { useClass: BrowserMessageService }],
            [ICommandService, { useClass: CommandService }],

            // --- Business Logic Registrations ---
            // To add a new view, simply add another line here like the one below.
            [IView, { useValue: McpControlView }],
        ]);

        const root = ReactDOM.createRoot(document.getElementById("app"));
        root.render(<AppWithDependencies />);
    </script>
</body>

</html>