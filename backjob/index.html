<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <script src="assets/tailwindcss.js"></script>
</head>

<body class="bg-gray-100 font-sans">
    <div id="app"></div>

    <script src="assets/vendor-bundle.umd.js"></script>
    <script src="assets/babel.min.js"></script>
    <script type="text/babel">

        // ===================================================================
        // ===================     FRAMEWORK CODE     ========================
        // ===================================================================
        // This section contains the reusable, application-agnostic core.
        // You should not need to modify this section to add new features.
        // -------------------------------------------------------------------

        // 等价于
        // import * as React from 'react';
        // import ReactDOM from 'react-dom/client';
        // import * as redi from '@wendellhu/redi';
        // import * as rediReact from '@wendellhu/redi/react-bindings';
        // import * as rxjs from 'rxjs';
        // import * as reactSpring from '@react-spring/web';
        const { React, ReactDOM, redi, rediReact, rxjs, reactSpring } = globalThis.__tmp;
        delete globalThis.__tmp;

        // keep unused import for redi and rediReact
        const {
            Inject,
            Injector,
            LookUp,
            Many,
            Optional,
            Quantity,
            RediError,
            Self,
            SkipSelf,
            WithNew,
            createIdentifier,
            forwardRef,
            isAsyncDependencyItem,
            isAsyncHook,
            isClassDependencyItem,
            isCtor,
            isDisposable,
            isFactoryDependencyItem,
            isValueDependencyItem,
            setDependencies,
        } = redi;
        const {
            RediConsumer,
            RediContext,
            RediProvider,
            WithDependency,
            connectDependencies,
            connectInjector,
            useDependency,
            useInjector,
            useObservable,
            useUpdateBinder,
        } = rediReact;
        const {
            useState,
            useEffect,
            useRef,
            useReducer,
            Fragment,
            useCallback,
            createContext,
            useContext,
        } = React;
        const { BehaviorSubject } = rxjs;
        const { useSpring, useTransition, animated } = reactSpring;

        // 1. FRAMEWORK: CORE COMMUNICATION SERVICES

        const IBackendEventService = createIdentifier("IBackendEventService");
        class BackendEventService {
            constructor() {
                this.subscribers = new Map();
            }

            subscribe(eventType, callback) {
                if (!this.subscribers.has(eventType)) {
                    this.subscribers.set(eventType, new Set());
                }
                this.subscribers.get(eventType).add(callback);
                return () => {
                    const eventSubscribers = this.subscribers.get(eventType);
                    if (eventSubscribers) {
                        eventSubscribers.delete(callback);
                    }
                };
            }

            publish(eventType, data) {
                const eventSubscribers = this.subscribers.get(eventType);
                if (eventSubscribers) {
                    eventSubscribers.forEach((callback) => callback(data));
                }
            }
        }
        setDependencies(BackendEventService, []);

        const IMessageService = createIdentifier("IMessageService");
        class BrowserMessageService {
            constructor(eventService) {
                this.eventService = eventService;
                this.requestId = 0;
                this.handleBackendResponse = this.handleBackendResponse.bind(this);
                this.initializeListener();
            }
            async call(type, payload) {
                const correlationId = `req-${this.requestId++}`;
                const command = { type, payload, correlationId, timestamp: new Date().toISOString() };
                window.parent.sendMessage("frontend:message", command);
                return correlationId;
            }
            initializeListener() {
                window.addEventListener("message", this.handleBackendResponse);
            }
            handleBackendResponse(event) {
                if (event.data && event.data.type === "backendResponse") {
                    try {
                        const response = JSON.parse(event.data.data);
                        this.eventService.publish("backendResponse", response);
                    } catch (e) {
                        console.error("Fatal error parsing backend response:", e, event.data.data);
                    }
                }
            }
            dispose() {
                window.removeEventListener("message", this.handleBackendResponse);
            }
        }
        setDependencies(BrowserMessageService, [IBackendEventService]);

        // 2. FRAMEWORK: HIGH-LEVEL COMMAND ABSTRACTION

        const ICommandService = createIdentifier("ICommandService");
        class CommandService {
            constructor(messageService, eventService) {
                this.messageService = messageService;
                this.pendingCommands = new Map();
                this.RPC_TIMEOUT = 10000;
                this.handleBackendResponse = this.handleBackendResponse.bind(this);
                eventService.subscribe("backendResponse", this.handleBackendResponse);
            }

            execute = (type, payload) => {
                return new Promise(async (resolve, reject) => {
                    const commandId = await this.messageService.call(type, payload);
                    const timeoutId = setTimeout(() => {
                        if (this.pendingCommands.has(commandId)) {
                            this.pendingCommands.delete(commandId);
                            reject(new Error(`Command '${type}' timed out.`));
                        }
                    }, this.RPC_TIMEOUT);
                    this.pendingCommands.set(commandId, { resolve, reject, timeoutId, type });
                });
            };

            handleBackendResponse(response) {
                const { correlationId, taskId } = response;
                if (correlationId && this.pendingCommands.has(correlationId)) {
                    // Sync RPC or Async Task Initiation
                    const cmd = this.pendingCommands.get(correlationId);
                    if (response.status === "success") {
                        if (response.data && response.data.taskId) {
                            // It's an async task starting. Transfer promise to the new taskId.
                            const newTaskId = response.data.taskId;
                            this.pendingCommands.delete(correlationId); // remove old correlationId
                            this.pendingCommands.set(newTaskId, cmd); // re-map with taskId
                        } else {
                            // It's a normal sync RPC response.
                            clearTimeout(cmd.timeoutId);
                            this.pendingCommands.delete(correlationId);
                            cmd.resolve(response.data);
                        }
                    } else {
                        // Error on initiation
                        clearTimeout(cmd.timeoutId);
                        this.pendingCommands.delete(correlationId);
                        cmd.reject(new Error(response.message || "An unknown backend error occurred."));
                    }
                } else if (taskId && this.pendingCommands.has(taskId)) {
                    // Async Task Completion
                    const cmd = this.pendingCommands.get(taskId);
                    clearTimeout(cmd.timeoutId); // In case we want a total task timeout
                    this.pendingCommands.delete(taskId);

                    if (response.status === "success") {
                        cmd.resolve(response.data);
                    } else {
                        cmd.reject(new Error(response.message || "Async task failed."));
                    }
                }
            }
        }
        setDependencies(CommandService, [IMessageService, IBackendEventService]);

        // 3. FRAMEWORK: UNIFIED REACT HOOK FOR UI COMPONENTS

        const useCommand = () => {
            const commandService = useDependency(ICommandService);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [data, setData] = useState(null);

            const execute = useCallback(async (type, payload) => {
                setIsLoading(true);
                setError(null);
                setData(null);
                try {
                    const result = await commandService.execute(type, payload);
                    setData(result);
                    return result;
                } catch (err) {
                    setError(err.message);
                    throw err;
                } finally {
                    setIsLoading(false);
                }
            }, [commandService]);

            return { execute, isLoading, error, data };
        };

        // 4. FRAMEWORK: BOOTSTRAPPING AND VIEW MANAGEMENT

        // ===================================================================
        // ================== NEW FRAMEWORK EXTENSIONS =======================
        // ===================================================================
        // 1. NEW: Frontend Event Bus Service
        const IEventBus = createIdentifier("IEventBus");
        // Using the same implementation as BackendEventService for simplicity
        class EventBusService extends BackendEventService { }
        setDependencies(EventBusService, []);

        // 2. REFACTORED: Panel Service powered by RxJS
        const IPanel = createIdentifier("IPanel");
        const IPanelService = createIdentifier("IPanelService");
        class PanelService {
            constructor(panels) {
                this.allPanels = new Map(panels.map(p => [p.id, p]));

                // Internal state managed by a BehaviorSubject
                this._state$ = new BehaviorSubject(this.getInitialState());

                // Publicly exposed observable stream of the state
                this.state$ = this._state$.asObservable();
            }

            getInitialState() {
                const initialOpenIds = new Set(
                    Array.from(this.allPanels.values())
                        .filter(p => p.defaultActive)
                        .map(p => p.id)
                );
                const initialActiveId = Array.from(this.allPanels.values())
                    .find(p => p.defaultActive)?.id || null;
                return this._computeState(initialOpenIds, initialActiveId);
            }

            // Private method to compute the full state object from IDs
            _computeState(openPanelIds, activePanelId) {
                const openPanels = Array.from(openPanelIds)
                    .map(id => this.allPanels.get(id))
                    .filter(Boolean); // Filter out potential undefineds
                const activePanel = activePanelId ? this.allPanels.get(activePanelId) : null;

                return { openPanels, activePanel };
            }

            // Private method to update the stream
            _updateState(newOpenIds, newActiveId) {
                const newState = this._computeState(newOpenIds, newActiveId);
                this._state$.next(newState);
            }

            // --- Public API for Panel Control ---
            openPanel(id) {
                if (!this.allPanels.has(id)) return;

                const currentState = this._state$.getValue();
                const currentOpenIds = new Set(currentState.openPanels.map(p => p.id));

                if (currentOpenIds.has(id)) {
                    this.setActivePanel(id);
                    return;
                }

                currentOpenIds.add(id);
                this._updateState(currentOpenIds, id);
            }

            closePanel(id) {
                const currentState = this._state$.getValue();
                const currentOpenIds = new Set(currentState.openPanels.map(p => p.id));
                if (!currentOpenIds.has(id)) return;

                currentOpenIds.delete(id);
                let newActiveId = currentState.activePanel?.id;
                if (newActiveId === id) {
                    newActiveId = currentOpenIds.values().next().value || null;
                }
                this._updateState(currentOpenIds, newActiveId);
            }

            setActivePanel(id) {
                const currentState = this._state$.getValue();
                if (currentState.activePanel?.id === id) return;

                const currentOpenIds = new Set(currentState.openPanels.map(p => p.id));
                if (!currentOpenIds.has(id)) return; // Can't activate a panel that isn't open

                this._updateState(currentOpenIds, id);
            }
        }
        setDependencies(PanelService, [[new Many(), IPanel]]);

        // 3. REFACTORED: The App Shell Component, now a pure projection of state
        const AppShell = () => {
            const panelService = useDependency(IPanelService);

            // Subscribe to the state stream.
            const { openPanels, activePanel } = useObservable(
                panelService.state$,
                panelService.getInitialState()
            );

            // Setup transitions for the active panel
            const panelTransitions = useTransition(activePanel, {
                key: panel => panel?.id,
                from: { opacity: 0, transform: 'translateY(10px)' },
                enter: { opacity: 1, transform: 'translateY(0px)' },
                leave: { opacity: 0, transform: 'translateY(-10px)', position: 'absolute', top: 0, left: 0, right: 0 },
                config: { tension: 220, friction: 25 },
            });

            return (
                <div className="p-4 max-w-5xl mx-auto bg-gray-50 shadow-lg rounded-lg mt-8 flex flex-col h-[90vh]">
                    <h1 className="text-3xl font-bold text-gray-800 mb-4 text-center">
                        Mendix Portal Control Panel (RxJS)
                    </h1>
                    <div className="flex border-b border-gray-300">
                        {openPanels.map(panel => (
                            <button
                                key={panel.id}
                                onClick={() => panelService.setActivePanel(panel.id)}
                                className={`px-4 py-2 text-sm font-medium border-b-2 ${panel.id === activePanel?.id ? 'border-purple-600 text-purple-700' : 'border-transparent text-gray-500 hover:text-gray-700'}`}
                            >
                                {panel.title}
                            </button>
                        ))}
                    </div>
                    <div className="flex-grow p-4 bg-white relative overflow-hidden">
                        {panelTransitions((style, panel) =>
                            panel ? (
                                <animated.div style={style} className="w-full h-full">
                                    <panel.component />
                                </animated.div>
                            ) : (
                                <div className="text-center text-gray-500">No panel selected.</div>
                            )
                        )}
                    </div>
                </div>
            );
        };

        const Alert = ({ message, type, style }) => {
            const baseClasses = "text-sm px-4 py-2 rounded-md";
            const typeClasses = {
                success: "bg-green-100 text-green-800",
                error: "bg-red-100 text-red-800",
            };
            return <animated.div style={style} className={`${baseClasses} ${typeClasses[type]}`}>{message}</animated.div>;
        };


        // ===================================================================
        // ===============     BUSINESS LOGIC CODE     =======================
        // ===================================================================
        // This section contains your feature-specific components (Views).
        // To add a new feature, add your new Component here and register
        // it as an `IView` in the IOC Configuration section below.
        // -------------------------------------------------------------------
        const JobStatusBadge = ({ status }) => {
            const config = {
                queued: { label: "等待中", classes: "bg-gray-100 text-gray-600" },
                running: { label: "执行中", classes: "bg-blue-100 text-blue-800 animate-pulse" },
                completed: { label: "已完成", classes: "bg-green-100 text-green-800" }
            };
            const current = config[status] || config.queued;
            return (
                <span className={`text-xs font-bold px-3 py-1 rounded-full uppercase tracking-wide ${current.classes}`}>
                    {current.label}
                </span>
            );
        };

        const StepItem = ({ step }) => {
            const isCompleted = step.status === 'completed';
            const isRunning = step.status === 'running';
            return (
                <div className="flex items-center text-sm">
                    <div className={`flex-shrink-0 flex items-center justify-center h-5 w-5 rounded-full mr-2 ${isCompleted ? 'bg-green-500' : isRunning ? 'bg-blue-500' : 'border-2 border-gray-300'
                        }`}>
                        {isCompleted && <svg className="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path></svg>}
                        {isRunning && <div className="w-1.5 h-1.5 bg-white rounded-full"></div>}
                    </div>
                    <span className={isCompleted ? 'text-gray-400 line-through' : 'text-gray-700'}>
                        {step.title}
                    </span>
                </div>
            );
        };

        const JobProgressBar = ({ steps }) => {
            const completed = steps.filter(s => s.status === 'completed').length;
            const progress = (completed / steps.length) * 100;
            const springProps = useSpring({ width: `${progress}%`, config: { tension: 210, friction: 20 } });
            return (
                <div className="w-full bg-gray-200 rounded-full h-2 my-3">
                    <animated.div className="bg-gradient-to-r from-blue-400 to-blue-600 h-2 rounded-full" style={springProps}></animated.div>
                </div>
            );
        };

        const JobCard = ({ job }) => (
            <div className="bg-white border border-gray-200 rounded-xl p-5 shadow-sm">
                <div className="flex justify-between items-start mb-2">
                    <h3 className="font-bold text-lg text-gray-800">{job.title}</h3>
                    <JobStatusBadge status={job.status} />
                </div>
                <JobProgressBar steps={job.steps} />
                <div className="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2 mt-4">
                    {job.steps.map(step => <StepItem key={step.title} step={step} />)}
                </div>
            </div>
        );

        const BackgroundJobPanel = () => {
            const { execute: startJob, isLoading: isStarting } = useCommand();
            const { execute: pollStatus } = useCommand();
            const [jobs, setJobs] = useState({});
            const POLLING_INTERVAL = 200;

            // --- FIX: Use a ref to hold the latest jobs state for the interval ---
            // The ref provides access to the latest state without being a dependency.
            const jobsRef = useRef(jobs);
            jobsRef.current = jobs; // Keep the ref updated on every render

            // --- FIX: The Polling Effect now runs only ONCE on mount ---
            useEffect(() => {
                const timerId = setInterval(async () => {
                    // Inside the interval, always read from the ref to get the LATEST jobs
                    const currentJobs = jobsRef.current;
                    const activeJobIds = Object.values(currentJobs)
                        .filter(job => job.status !== 'completed')
                        .map(job => job.jobId);

                    // If there are no active jobs, no need to make an API call
                    if (activeJobIds.length === 0) {
                        return;
                    }

                    try {
                        const updatedStates = await pollStatus("GET_JOB_STATUS", { jobIds: activeJobIds });
                        // Use the functional form of setJobs to safely update state
                        // based on the previous state, preventing race conditions.
                        setJobs(prevJobs => {
                            const newJobs = { ...prevJobs };
                            for (const jobId in updatedStates) {
                                if (updatedStates[jobId]) {
                                    newJobs[jobId] = updatedStates[jobId];
                                }
                            }
                            return newJobs;
                        });
                    } catch (error) {
                        console.error("Polling failed:", error);
                    }
                }, POLLING_INTERVAL);

                // Cleanup function: clear the single, long-running interval when the component unmounts.
                return () => clearInterval(timerId);

            }, []); // An empty dependency array means this effect runs only once.

            const handleStartNewJob = async () => {
                const timestamp = new Date().toLocaleTimeString();
                const result = await startJob("START_BACKGROUND_JOB", { title: `自动分析作业 [${timestamp}]` });
                if (result && result.jobId) {
                    setJobs(prev => ({ [result.jobId]: result, ...prev }));
                }
            };

            const jobList = Object.values(jobs).sort((a, b) => b.jobId.localeCompare(a.jobId));

            const transitions = useTransition(jobList, {
                from: { opacity: 0, transform: 'translateY(-20px)' },
                enter: { opacity: 1, transform: 'translateY(0px)' },
                leave: { opacity: 0, position: 'absolute' },
                keys: item => item.jobId,
                trail: 1000
            });

            // The JSX part remains the same as it correctly renders based on the 'jobs' state.
            return (
                 <div className="h-full flex flex-col">
                    <div className="flex justify-between items-center mb-6">
                        <div>
                            <h2 className="text-2xl font-bold text-gray-800">Mendix 作业中心 (轮询)</h2>
                            <p className="text-sm text-gray-500">通过前端轮询获取原生作业进度</p>
                        </div>
                        <button
                            onClick={handleStartNewJob}
                            disabled={isStarting}
                            className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all disabled:opacity-50 flex items-center"
                        >
                            {isStarting && <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>}
                            创建新作业
                        </button>
                    </div>
                    <div className="flex-1 overflow-y-auto pr-2 space-y-4 relative">
                        {transitions((style, job) => (
                           <animated.div style={style}>
                                <JobCard job={job} />
                           </animated.div>
                        ))}
                        {jobList.length === 0 && !isStarting && (
                            <div className="text-center py-20 text-gray-400 border-2 border-dashed border-gray-300 rounded-xl">
                                <p className="font-semibold">暂无作业</p>
                                <p className="text-sm mt-1">点击右上角按钮以创建一个新作业</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };


        // ===================================================================
        // ==============     IOC & APP INITIALIZATION     ===================
        // ===================================================================

        const AppWithDependencies = connectDependencies(AppShell, [
            // --- Framework Registrations ---
            [IBackendEventService, { useClass: BackendEventService }],
            [IMessageService, { useClass: BrowserMessageService }],
            [ICommandService, { useClass: CommandService }],
            [IEventBus, { useClass: EventBusService }],
            [IPanelService, { useClass: PanelService }],

            // --- Business Logic Registrations (as Panels) ---
            [IPanel, { useValue: { id: 'bg-jobs', title: '后台作业监控', component: BackgroundJobPanel, defaultActive: true } }],
        ]);

        const root = ReactDOM.createRoot(document.getElementById("app"));
        root.render(<AppWithDependencies />);
    </script>
</body>

</html>