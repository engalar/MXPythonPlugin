<!DOCTYPE html>
<html lang="en">

<head>
    <style>/**plugin microflow 2026.1.3**/</style>
    <meta charset="UTF-8" />
    <script src="assets/tailwindcss.js"></script>
</head>

<body class="bg-gray-100 font-sans">
    <div id="app"></div>

    <script src="assets/vendor-bundle.umd.js"></script>
    <script src="assets/babel.min.js"></script>
    <script type="text/babel">

        // ===================================================================
        // ===================     FRAMEWORK CODE     ========================
        // ===================================================================
        // This section contains the reusable, application-agnostic core.
        // You should not need to modify this section to add new features.
        // -------------------------------------------------------------------

        // 等价于
        // import * as React from 'react';
        // import ReactDOM from 'react-dom/client';
        // import * as redi from '@wendellhu/redi';
        // import * as rediReact from '@wendellhu/redi/react-bindings';
        // import * as rxjs from 'rxjs';
        // import * as reactSpring from '@react-spring/web';
        const { React, ReactDOM, redi, rediReact, rxjs, reactSpring } = globalThis.__tmp;
        delete globalThis.__tmp;

        // keep unused import for redi and rediReact
        const {
            Inject,
            Injector,
            LookUp,
            Many,
            Optional,
            Quantity,
            RediError,
            Self,
            SkipSelf,
            WithNew,
            createIdentifier,
            forwardRef,
            isAsyncDependencyItem,
            isAsyncHook,
            isClassDependencyItem,
            isCtor,
            isDisposable,
            isFactoryDependencyItem,
            isValueDependencyItem,
            setDependencies,
        } = redi;
        const {
            RediConsumer,
            RediContext,
            RediProvider,
            WithDependency,
            connectDependencies,
            connectInjector,
            useDependency,
            useInjector,
            useObservable,
            useUpdateBinder,
        } = rediReact;
        const {
            useState,
            useEffect,
            useRef,
            useReducer,
            Fragment,
            useCallback,
            createContext,
            useContext,
        } = React;
        const { BehaviorSubject, Subject, fromEvent, map, filter, bufferTime } = rxjs;
        const { useSpring, useTransition, animated } = reactSpring;

        // 1. FRAMEWORK: CORE COMMUNICATION SERVICES

        // --- Telemetry Service ---
        const ITelemetryService = createIdentifier('ITelemetryService');
        
        class TelemetryService {
            constructor() {
                this.span$ = new Subject();
                this.jaegerEndpoint = "http://localhost:9411/api/v2/spans";
                this.span$.pipe(
                    bufferTime(5000, null, 10),
                    filter(batch => batch.length > 0)
                ).subscribe(spans => this.exportBatch(spans));
            }

            genId(len) { return [...Array(len)].map(() => Math.floor(Math.random() * 16).toString(16)).join(''); }

            // 增强：支持传入 parentSpan 建立链路
            startSpan(name, attributes = {}, parentSpan = null) {
                const traceId = parentSpan ? parentSpan.traceId : (attributes.traceId || this.genId(32));
                const parentId = parentSpan ? parentSpan.spanId : undefined;
                const spanId = this.genId(16);
                const startTime = Date.now();

                return {
                    traceId,
                    spanId,
                    parentId,
                    end: (endAttr = {}) => {
                        this.span$.next({
                            traceId, id: spanId, parentId, name,
                            timestamp: startTime * 1000,
                            duration: (Date.now() - startTime) * 1000,
                            localEndpoint: { serviceName: "studio-plugin[microflow]" },
                            tags: { ...attributes, ...endAttr, user_agent: navigator.userAgent }
                        });
                    }
                };
            }

            exportBatch(spans) {
                window.parent.sendMessage('frontend:message', {
                    type: 'telemetry', method: 'export',
                    params: { endpoint: this.jaegerEndpoint, spans: spans }
                });
            }
        }

        const IApiService = createIdentifier('IApiService');

        class ApiService {
            constructor(telemetry) {
                this.telemetry = telemetry;
                this.reqIdCounter = 0;
                this.pendingRpcs = new Map();
                this.activeJobs = new Map();
                this.activeSessions = new Map();
                this.broadcastChannels = new Map();

                fromEvent(window, 'message')
                    .pipe(filter(event => event.data && event.data.type === 'backendResponse'))
                    .pipe(map(event => JSON.parse(event.data.data)))
                    .subscribe(msg => this._handleBackendMessage(msg));
            }

            rpc(method, params, parentSpan = null) {
                const span = this.telemetry.startSpan(`RPC:${method}`, { method, params: JSON.stringify(params) }, parentSpan);
                return new Promise((resolve, reject) => {
                    const reqId = `req-${this.reqIdCounter++}`;
                    this.pendingRpcs.set(reqId, { resolve, reject, span }); // 将 span 存入 pending
                    this._sendMessage({ type: 'RPC', reqId, method, params, traceId: span.traceId, spanId: span.spanId });
                    
                    setTimeout(() => {
                        if (this.pendingRpcs.has(reqId)) {
                            this.pendingRpcs.delete(reqId);
                            span.end({ error: 'timeout' });
                            reject(new Error(`RPC call '${method}' timed out.`));
                        }
                    }, 15000);
                });
            }

            startJob(method, params, parentSpan = null) {
                const span = this.telemetry.startSpan(`JOB_START:${method}`, { method }, parentSpan);
                const subject = new Subject();
                const reqId = `req-${this.reqIdCounter++}`;

                const promise = new Promise((resolve, reject) => {
                    this.pendingRpcs.set(reqId, {
                        resolve: ({ jobId }) => {
                            span.end({ jobId });
                            this.activeJobs.set(jobId, { subject, parentSpan: span }); // 关联 span 供后续进度追踪
                            resolve({ jobId });
                        },
                        reject: (err) => {
                            span.end({ error: true, ...err });
                            reject(err);
                        }
                    });
                });

                this._sendMessage({ type: 'JOB_START', reqId, method, params, traceId: span.traceId, spanId: span.spanId });
                return { startPromise: promise, updates$: subject.asObservable() };
            }

            connectSession(channel, payload) {
                const sessionId = `${channel}-${Math.random().toString(36).substr(2, 9)}`;
                if (!this.activeSessions.has(sessionId)) {
                    const subject = new Subject();
                    this.activeSessions.set(sessionId, subject);
                    this._sendMessage({ type: 'SESSION_CONNECT', sessionId, channel, payload });
                }
                return { sessionId, messages$: this.activeSessions.get(sessionId).asObservable() };
            }

            disconnectSession(sessionId, channel) {
                if (this.activeSessions.has(sessionId)) {
                    this.activeSessions.get(sessionId).complete();
                    this.activeSessions.delete(sessionId);
                    this._sendMessage({ type: 'SESSION_DISCONNECT', sessionId, channel });
                }
            }

            subscribeBroadcast(channel) {
                if (!this.broadcastChannels.has(channel)) {
                    this.broadcastChannels.set(channel, new Subject());
                }
                return this.broadcastChannels.get(channel).asObservable();
            }

            _sendMessage(data) { window.parent.sendMessage('frontend:message', data); }

            _handleBackendMessage(msg) {
                const { type, reqId, jobId, sessionId, channel } = msg;

                switch (type) {
                    case 'RPC_SUCCESS':
                        const rpcInfo = this.pendingRpcs.get(reqId);
                        rpcInfo?.span?.end({ status: 'success' });
                        rpcInfo?.resolve(msg.data);
                        this.pendingRpcs.delete(reqId);
                        break;
                    case 'RPC_ERROR':
                        const rpcErrInfo = this.pendingRpcs.get(reqId);
                        rpcErrInfo?.span?.end({ error: true, message: msg.message });
                        rpcErrInfo?.reject({ message: msg.message, traceback: msg.traceback });
                        this.pendingRpcs.delete(reqId);
                        break;
                    case 'JOB_STARTED':
                        this.pendingRpcs.get(reqId)?.resolve({ jobId });
                        this.pendingRpcs.delete(reqId);
                        break;
                    case 'JOB_PROGRESS':
                        this.activeJobs.get(jobId)?.subject.next({ type: 'JOB_PROGRESS', ...msg });
                        break;
                    case 'JOB_SUCCESS':
                        const jobSuccess = this.activeJobs.get(jobId);
                        jobSuccess?.subject.next({ type: 'JOB_SUCCESS', ...msg });
                        jobSuccess?.subject.complete();
                        this.activeJobs.delete(jobId);
                        break;
                    case 'JOB_ERROR':
                        const jobError = this.activeJobs.get(jobId);
                        jobError?.subject.next({ type: 'JOB_ERROR', ...msg });
                        jobError?.subject.complete();
                        this.activeJobs.delete(jobId);
                        break;
                    case 'EVENT_BROADCAST':
                        this.broadcastChannels.get(channel)?.next(msg.data);
                        break;
                    case 'EVENT_SESSION':
                        this.activeSessions.get(sessionId)?.next(msg.data);
                        break;
                }
            }
        }
        setDependencies(ApiService, [ITelemetryService]);

        // --- High-Level React Hooks (Simplifying Boilerplate) ---

        function useRpc(method) {
            const api = useDependency(IApiService);
            const telemetry = useDependency(ITelemetryService);
            const [state, setState] = useState({ isLoading: false, data: null, error: null });

            const execute = useCallback(async (params) => {
                const uiSpan = telemetry.startSpan(`UI_EXECUTE:${method}`);
                setState({ isLoading: true, data: null, error: null });
                try {
                    const result = await api.rpc(method, params, uiSpan);
                    setState({ isLoading: false, data: result, error: null });
                    uiSpan.end({ result: 'ok' });
                    return result;
                } catch (err) {
                    setState({ isLoading: false, data: null, error: err });
                    uiSpan.end({ result: 'error', error_msg: err.message });
                    throw err;
                }
            }, [api, telemetry, method]);
            return { ...state, execute };
        }

        const initialJobState = { status: 'idle', progress: { percent: 0, message: '' }, data: null, error: null };
        
        function useJob(method) {
            const api = useDependency(IApiService);
            const telemetry = useDependency(ITelemetryService);
            const [state, setState] = useState(initialJobState);
            const subRef = useRef(null);

            const start = useCallback((params, parentSpan = null) => {
                const uiSpan = telemetry.startSpan(`UI_JOB_RUN:${method}`, {}, parentSpan);
                setState({ ...initialJobState, status: 'starting' });
                
                const { startPromise, updates$ } = api.startJob(method, params, uiSpan);

                startPromise.then(({ jobId }) => {
                    subRef.current = updates$.subscribe({
                        next: (update) => {
                            if (update.type === "JOB_PROGRESS") {
                                setState(s => ({ ...s, status: 'running', progress: update.progress }));
                            } else if (update.type === "JOB_SUCCESS") {
                                uiSpan.end({ status: 'completed' });
                                setState(s => ({ ...s, status: 'success', data: update.data, progress: { ...s.progress, percent: 100 } }));
                            } else if (update.type === 'JOB_ERROR') {
                                uiSpan.end({ status: 'failed', error: update.message });
                                setState(s => ({ ...s, status: 'error', error: { message: update.message, traceback: update.traceback } }));
                            }
                        },
                        error: (err) => {
                            uiSpan.end({ status: 'stream_error', error: err.message });
                            setState(s => ({ ...s, status: 'error', error: err }));
                        }
                    });
                }).catch(err => {
                    uiSpan.end({ status: 'start_failed', error: err.message });
                    setState({ ...initialJobState, status: 'error', error: err });
                });
            }, [api, telemetry, method]);

            useEffect(() => { return () => subRef.current?.unsubscribe(); }, []);

            return { ...state, start };
        }

        function usePush(channel, options = {}) {
            const api = useDependency(IApiService);
            const [latestMessage, setLatestMessage] = useState(null);

            useEffect(() => {
                let sub;
                let sessionId;

                if (options.isSession) {
                    const session = api.connectSession(channel, options.payload);
                    sessionId = session.sessionId;
                    sub = session.messages$.subscribe(setLatestMessage);
                } else {
                    sub = api.subscribeBroadcast(channel).subscribe(setLatestMessage);
                }

                return () => {
                    sub?.unsubscribe();
                    if (sessionId) {
                        api.disconnectSession(sessionId, channel);
                    }
                };
            }, [api, channel, options.isSession, JSON.stringify(options.payload)]); // re-run if payload changes

            return { latestMessage };
        }

        // 2. REFACTORED: Panel Service powered by RxJS
        const IPanel = createIdentifier("IPanel");
        const IPanelService = createIdentifier("IPanelService");
        class PanelService {
            constructor(panels) {
                this.allPanels = new Map(panels.map(p => [p.id, p]));

                // Internal state managed by a BehaviorSubject
                this._state$ = new BehaviorSubject(this.getInitialState());

                // Publicly exposed observable stream of the state
                this.state$ = this._state$.asObservable();
            }

            getInitialState() {
                const initialOpenIds = new Set(
                    Array.from(this.allPanels.values())
                        .filter(p => p.defaultActive)
                        .map(p => p.id)
                );
                const initialActiveId = Array.from(this.allPanels.values())
                    .find(p => p.defaultActive)?.id || null;
                return this._computeState(initialOpenIds, initialActiveId);
            }

            // Private method to compute the full state object from IDs
            _computeState(openPanelIds, activePanelId) {
                const openPanels = Array.from(openPanelIds)
                    .map(id => this.allPanels.get(id))
                    .filter(Boolean); // Filter out potential undefineds
                const activePanel = activePanelId ? this.allPanels.get(activePanelId) : null;

                return { openPanels, activePanel };
            }

            // Private method to update the stream
            _updateState(newOpenIds, newActiveId) {
                const newState = this._computeState(newOpenIds, newActiveId);
                this._state$.next(newState);
            }

            // --- Public API for Panel Control ---
            openPanel(id) {
                if (!this.allPanels.has(id)) return;

                const currentState = this._state$.getValue();
                const currentOpenIds = new Set(currentState.openPanels.map(p => p.id));

                if (currentOpenIds.has(id)) {
                    this.setActivePanel(id);
                    return;
                }

                currentOpenIds.add(id);
                this._updateState(currentOpenIds, id);
            }

            closePanel(id) {
                const currentState = this._state$.getValue();
                const currentOpenIds = new Set(currentState.openPanels.map(p => p.id));
                if (!currentOpenIds.has(id)) return;

                currentOpenIds.delete(id);
                let newActiveId = currentState.activePanel?.id;
                if (newActiveId === id) {
                    newActiveId = currentOpenIds.values().next().value || null;
                }
                this._updateState(currentOpenIds, newActiveId);
            }

            setActivePanel(id) {
                const currentState = this._state$.getValue();
                if (currentState.activePanel?.id === id) return;

                const currentOpenIds = new Set(currentState.openPanels.map(p => p.id));
                if (!currentOpenIds.has(id)) return; // Can't activate a panel that isn't open

                this._updateState(currentOpenIds, id);
            }
        }
        setDependencies(PanelService, [[new Many(), IPanel]]);

        // 3. REFACTORED: The App Shell Component, now a pure projection of state
        const AppShell = () => {
            const panelService = useDependency(IPanelService);

            // Subscribe to the state stream.
            const { openPanels, activePanel } = useObservable(
                panelService.state$,
                panelService.getInitialState()
            );

            // Setup transitions for the active panel
            const panelTransitions = useTransition(activePanel, {
                key: panel => panel?.id,
                from: { opacity: 0, transform: 'translateY(10px)' },
                enter: { opacity: 1, transform: 'translateY(0px)' },
                leave: { opacity: 0, transform: 'translateY(-10px)', position: 'absolute', top: 0, left: 0, right: 0 },
                config: { tension: 220, friction: 25 },
            });

            return (
                <div className="p-4 max-w-5xl mx-auto bg-gray-50 shadow-lg rounded-lg flex flex-col h-[100vh]">
                    <h1 className="text-3xl font-bold text-gray-800 mb-4 text-center">
                        Mendix Portal Control Panel (RxJS)
                    </h1>
                    <div className="flex border-b border-gray-300">
                        {openPanels.map(panel => (
                            <button
                                key={panel.id}
                                onClick={() => panelService.setActivePanel(panel.id)}
                                className={`px-4 py-2 text-sm font-medium border-b-2 ${panel.id === activePanel?.id ? 'border-purple-600 text-purple-700' : 'border-transparent text-gray-500 hover:text-gray-700'}`}
                            >
                                {panel.title}
                            </button>
                        ))}
                    </div>
                    <div className="flex-grow p-4 bg-white relative overflow-hidden">
                        {panelTransitions((style, panel) =>
                            panel ? (
                                <animated.div style={style} className="w-full h-full">
                                    <panel.component />
                                </animated.div>
                            ) : (
                                <div className="text-center text-gray-500">No panel selected.</div>
                            )
                        )}
                    </div>
                </div>
            );
        };

        const Alert = ({ message, type, style }) => {
            const baseClasses = "text-sm px-4 py-2 rounded-md";
            const typeClasses = {
                success: "bg-green-100 text-green-800",
                error: "bg-red-100 text-red-800",
            };
            return <animated.div style={style} className={`${baseClasses} ${typeClasses[type]}`}>{message}</animated.div>;
        };
        const ErrorDisplay = ({ error }) => {
            if (!error) return null;
            const [showTraceback, setShowTraceback] = useState(false);

            return (
                <div className="mt-4 p-3 bg-red-100 text-red-800 rounded-lg border border-red-200">
                    <div className="flex justify-between items-center">
                        <p className="font-semibold break-all">Error: {error.message}</p>
                        {error.traceback && (
                            <button
                                onClick={() => setShowTraceback(!showTraceback)}
                                className="text-xs text-red-600 hover:text-red-800 font-medium ml-4 flex-shrink-0"
                            >
                                {showTraceback ? 'Hide Details' : 'Show Details'}
                            </button>
                        )}
                    </div>
                    {showTraceback && error.traceback && (
                        <pre className="mt-3 p-2 bg-red-50 text-xs text-red-900 overflow-auto rounded font-mono">
                            <code>{error.traceback}</code>
                        </pre>
                    )}
                </div>
            );
        };

        // ===================================================================
        // ===============     BUSINESS LOGIC CODE     =======================
        // ===================================================================
        // This section contains your feature-specific components (Views).
        // To add a new feature, add your new Component here and register
        // it as an `IView` in the IOC Configuration section below.
        // -------------------------------------------------------------------

        const MicroflowGeneratorPanel = () => {
            const telemetry = useDependency(ITelemetryService);
            const { status, progress, data, error, start } = useJob('microflow:generate');
            const [logs, setLogs] = useState([]);
            const logsEndRef = useRef(null);

            const scrollToBottom = () => {
                logsEndRef.current?.scrollIntoView({ behavior: "smooth", block: "end" });
            };

            useEffect(() => {
                if (progress?.metadata?.logs) {
                    setLogs(progress.metadata.logs);
                }
            }, [progress]);

            useEffect(scrollToBottom, [logs]);

            const handleStart = async() => {
                setLogs([]);
                // 启动追踪
                const span = telemetry.startSpan('MicroflowGeneratorPanel:handleStart', { rpc: 'useJob:microflow:generate' });
                
                // 传递 traceId 到后端 Job
                await start({}, span);
                
                span.end({ action: 'start_job' });
            };

            const isRunning = status === 'starting' || status === 'running';

            return (
                <div className="flex flex-col h-full">
                    <div className="flex-shrink-0">
                        <h2 className="text-xl font-semibold text-gray-700 mb-2">Microflow Generator</h2>
                        <p className="text-sm text-gray-500 mb-4">
                            Click to execute a Python script that programmatically creates a new module ('MyOrderModule') with a domain model, an enumeration, associations, and a complex order processing microflow. The entire operation is performed within a single transaction.
                        </p>
                        <button
                            onClick={handleStart}
                            disabled={isRunning}
                            className="w-full px-4 py-3 bg-purple-600 text-white font-semibold rounded-md hover:bg-purple-700 disabled:bg-purple-300 transition-colors shadow-sm"
                        >
                            {isRunning ? `Running (${progress.percent.toFixed(0)}%)...` : 'Generate Order Management Solution'}
                        </button>
                    </div>

                    {status !== 'idle' && (
                        <div className="mt-4 flex-grow flex flex-col min-h-0">
                            <div className="flex-shrink-0 p-4 border rounded-t-lg bg-gray-50">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="font-semibold text-gray-700">{progress.stage || 'Progress'}</span>
                                    <span className="text-sm font-mono text-purple-600">{progress.percent.toFixed(1)}%</span>
                                </div>
                                <div className="w-full bg-gray-200 rounded-full h-2.5">
                                    <div className="bg-purple-500 h-2.5 rounded-full transition-all duration-300" style={{ width: `${progress.percent}%` }}></div>
                                </div>
                                <p className="text-center text-sm text-gray-600 mt-2 truncate">{progress.message}</p>
                            </div>

                            <div className="flex-grow p-3 bg-gray-800 text-white font-mono text-xs rounded-b-md overflow-y-auto">
                                {logs.map((log, index) => (
                                    <p key={index} className={`whitespace-pre-wrap ${log.includes("---") ? 'text-purple-300 font-bold mt-1' : ''}`}>
                                        <span className="text-gray-500 mr-2 select-none">{String(index + 1).padStart(3, '0')}</span>
                                        {log}
                                    </p>
                                ))}
                                <div ref={logsEndRef} />
                            </div>

                            {status === 'success' && (
                                <div className="mt-3 p-3 bg-green-100 text-green-800 rounded text-center font-semibold">
                                    Success! Module '{data.module}' and its artifacts have been created. Check your App Explorer.
                                </div>
                            )}
                            {status === 'error' && <ErrorDisplay error={error} />}
                        </div>
                    )}
                </div>
            );
        };

        // ===================================================================
        // ==============     IOC & APP INITIALIZATION     ===================
        // ===================================================================

        const AppWithDependencies = connectDependencies(() => {
            const panelService = useDependency(IPanelService);
            const { openPanels, activePanel } = useObservable(panelService.state$, panelService.getInitialState());

            // Setup transitions for the active panel
            const panelTransitions = useTransition(activePanel, {
                key: panel => panel?.id,
                from: { opacity: 0, transform: 'translateY(10px)' },
                enter: { opacity: 1, transform: 'translateY(0px)' },
                leave: { opacity: 0, transform: 'translateY(-10px)', position: 'absolute', top: 0, left: 0, right: 0 },
                config: { tension: 220, friction: 25 },
            });


            return (
                <div className="p-4 max-w-5xl mx-auto bg-gray-50 shadow-lg rounded-lg flex flex-col h-[100vh]">
                    <div className="flex border-b border-gray-300">
                        {openPanels.map(panel => (
                            <button key={panel.id} onClick={() => panelService.setActivePanel(panel.id)}
                                className={`px-4 py-2 text-sm font-medium border-b-2 ${panel.id === activePanel?.id ? 'border-blue-600 text-blue-700' : 'border-transparent text-gray-500 hover:text-gray-700'}`}>
                                {panel.title}
                            </button>
                        ))}
                    </div>
                    <div className="flex-grow p-4 bg-white relative overflow-hidden">
                        {panelTransitions((style, panel) =>
                            panel ? (
                                <animated.div style={style} className="w-full h-full">
                                    <panel.component />
                                </animated.div>
                            ) : (
                                <div className="text-center text-gray-500">No panel selected.</div>
                            )
                        )}
                    </div>
                </div>
            );
        }, [
            // --- Framework Registrations ---
            [IApiService, { useClass: ApiService }],
            [IPanelService, { useClass: PanelService }],
            [ITelemetryService, { useClass: TelemetryService }],

            // --- Business Logic Registrations (as Panels) ---
            [IPanel, { useValue: { id: 'mf-generator', title: 'Microflow Generator', component: MicroflowGeneratorPanel, defaultActive: true } }],
        ]);

        const root = ReactDOM.createRoot(document.getElementById("app"));
        root.render(<AppWithDependencies />);
    </script>
</body>

</html>