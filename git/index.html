<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <script src="assets/tailwindcss.js"></script>
</head>
<body class="bg-gray-100 font-sans">
    <div id="app"></div>

    <script src="assets/vendor-bundle.umd.js"></script>
    <script src="assets/babel.min.js"></script>
    <script type="text/babel">
        const { React, ReactDOM, redi, rediReact } = globalThis.__tmp;
        delete globalThis.__tmp;

        // keep unused import for redi and rediReact
        const {
            Inject,
            Injector,
            LookUp,
            Many,
            Optional,
            Quantity,
            RediError,
            Self,
            SkipSelf,
            WithNew,
            createIdentifier,
            forwardRef,
            isAsyncDependencyItem,
            isAsyncHook,
            isClassDependencyItem,
            isCtor,
            isDisposable,
            isFactoryDependencyItem,
            isValueDependencyItem,
            setDependencies,
        } = redi;
        const {
            RediConsumer,
            RediContext,
            RediProvider,
            WithDependency,
            connectDependencies,
            connectInjector,
            useDependency,
            useInjector,
            useObservable,
            useUpdateBinder,
        } = rediReact;
        const { useState, useEffect, useReducer, Fragment, useCallback, createContext, useContext } = React;

        // ===================================================================
        // 1. STATE & COMMUNICATION SERVICES
        // ===================================================================

        const IMessageService = createIdentifier("IMessageService");
        class BrowserMessageService {
            constructor() {
                this.requestId = 0;
                this.pendingRequests = new Map();
                this.initializeListener();
                this.RPC_TIMEOUT = 10000;
            }
            async call(type, payload) {
                const correlationId = `req-${this.requestId++}`;
                const command = { type, payload, correlationId, timestamp: new Date().toISOString() };
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        if (this.pendingRequests.has(correlationId)) {
                            this.pendingRequests.delete(correlationId);
                            reject(new Error(`RPC call timed out for type '${type}'`));
                        }
                    }, this.RPC_TIMEOUT);
                    this.pendingRequests.set(correlationId, { resolve, reject, timeoutId });
                    window.parent.sendMessage("frontend:message", command);
                });
            }
            initializeListener() {
                window.addEventListener("message", this.handleBackendResponse);
            }
            handleBackendResponse = (event) => {
                if (!(event.data && event.data.type === "backendResponse")) return;
                try {
                    const response = JSON.parse(event.data.data);
                    const { correlationId } = response;
                    if (!correlationId || !this.pendingRequests.has(correlationId)) return;
                    const { resolve, reject, timeoutId } = this.pendingRequests.get(correlationId);
                    clearTimeout(timeoutId);
                    this.pendingRequests.delete(correlationId);
                    if (response.status === "success") {
                        resolve(response.data);
                    } else {
                        reject(new Error(response.message || "An unknown backend error occurred."));
                    }
                } catch (e) {
                    console.error("Fatal error parsing backend response:", e, event.data.data);
                }
            };
            dispose() {
                window.removeEventListener("message", this.handleBackendResponse);
            }
        }
        setDependencies(BrowserMessageService, []);

        const IView = createIdentifier("IView");
        class ViewManagementService {
            constructor(views) { this.views = views; }
            getViews() { return this.views; }
        }
        setDependencies(ViewManagementService, [[new Many(), IView]]);

        // ===================================================================
        // 2. REUSABLE HOOKS (Centralized stateful logic)
        // ===================================================================

        const useRpc = () => {
            const messageService = useDependency(IMessageService);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [data, setData] = useState(null);

            const execute = useCallback(
                async (type, payload) => {
                    setIsLoading(true);
                    setError(null);
                    setData(null);
                    try {
                        const result = await messageService.call(type, payload);
                        setData(result);
                        return result;
                    } catch (err) {
                        setError(err.message);
                        throw err;
                    } finally {
                        setIsLoading(false);
                    }
                },
                [messageService]
            );
            return { execute, isLoading, error, data, setData };
        };
        
        // --- START: New Reusable Hook for Pagination ---
        const usePaginatedRpc = (rpcType, pageSize = 20) => {
            const messageService = useDependency(IMessageService);
            const [isLoading, setIsLoading] = useState(true);
            const [isLoadingMore, setIsLoadingMore] = useState(false);
            const [error, setError] = useState(null);
            const [items, setItems] = useState([]);
            const [page, setPage] = useState(1);
            const [hasMore, setHasMore] = useState(true);

            const load = useCallback(async (pageNum) => {
                if (pageNum === 1) {
                    setIsLoading(true);
                } else {
                    setIsLoadingMore(true);
                }
                setError(null);

                try {
                    const data = await messageService.call(rpcType, { page: pageNum, pageSize });
                    setItems(prevItems => pageNum === 1 ? data.commits : [...prevItems, ...data.commits]);
                    setHasMore(data.hasMore);
                    setPage(pageNum + 1);
                } catch (err) {
                    setError(err.message);
                } finally {
                    setIsLoading(false);
                    setIsLoadingMore(false);
                }
            }, [messageService, rpcType, pageSize]);

            const reload = useCallback(() => load(1), [load]);
            const loadMore = useCallback(() => {
                if (!isLoadingMore && hasMore) {
                    load(page);
                }
            }, [isLoadingMore, hasMore, load, page]);
            
            useEffect(() => {
                reload();
            }, [reload]);

            return { isLoading, isLoadingMore, error, items, hasMore, loadMore, reload };
        };
        // --- END: New Reusable Hook for Pagination ---
        
        // ===================================================================
        // 3. CENTRALIZED STATE MANAGEMENT (Using React Context)
        // ===================================================================

        // --- START: New Git Context for shared state ---
        const GitContext = createContext(null);

        const GitProvider = ({ children }) => {
            const { execute, isLoading, error, data: status } = useRpc();
            const refetchStatus = useCallback(() => execute("GET_GIT_STATUS", {}), [execute]);

            const contextValue = {
                status,
                isLoading,
                error,
                refetchStatus,
                isRepo: status?.isRepo,
            };

            return (
                <GitContext.Provider value={contextValue}>
                    {children}
                </GitContext.Provider>
            );
        };

        const useGit = () => {
            const context = useContext(GitContext);
            if (!context) {
                throw new Error('useGit must be used within a GitProvider');
            }
            return context;
        };
        // --- END: New Git Context ---

        // ===================================================================
        // 4. UI COMPONENTS (Refactored for clarity and context usage)
        // ===================================================================
        
        const Alert = ({ message, type = "error" }) => {
            if (!message) return null;
            const colors = {
                error: "bg-red-100 border-red-400 text-red-700",
                success: "bg-green-100 border-green-400 text-green-700",
            };
            return (
                <div className={`${colors[type]} border px-4 py-3 rounded relative mb-4`} role="alert">
                    <span className="block sm:inline">{message}</span>
                </div>
            );
        };
        
        // --- GitInitView now uses useGit to refetch status ---
        const GitInitView = () => {
            const [message, setMessage] = useState("Initial commit");
            const { execute, isLoading, error } = useRpc();
            const { refetchStatus } = useGit();

            const handleInit = async () => {
                if (!message.trim()) return;
                try {
                    await execute("GIT_INIT_COMMIT", { message });
                    refetchStatus(); // Refetch global status after initialization
                } catch (e) { /* error is handled by the hook */ }
            };

            return (
                <div className="p-6 bg-yellow-50 border-2 border-dashed border-yellow-400 rounded-lg text-center">
                    <h3 className="text-xl font-semibold text-gray-800">Not a Git Repository</h3>
                    <p className="text-gray-600 my-4">This project is not yet under version control.</p>
                    <Alert message={error} />
                    <div className="flex items-center justify-center space-x-2">
                        <input type="text" value={message} onChange={(e) => setMessage(e.target.value)} placeholder="Initial commit message" className="w-full max-w-sm px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" disabled={isLoading} />
                        <button onClick={handleInit} disabled={isLoading} className="px-4 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 disabled:bg-blue-300 disabled:cursor-not-allowed">
                            {isLoading ? "Initializing..." : "Initialize & Commit"}
                        </button>
                    </div>
                </div>
            );
        };

        // --- BranchSelector now uses useGit ---
        const BranchSelector = () => {
            const { status, refetchStatus } = useGit();
            const { execute, isLoading, error } = useRpc();
            const [actionStatus, setActionStatus] = useState(null);

            const handleSwitch = async (e) => {
                const newBranch = e.target.value;
                if (newBranch === status.currentBranch) return;
                setActionStatus(null);
                try {
                    await execute("GIT_SWITCH_BRANCH", { branchName: newBranch });
                    setActionStatus({ type: 'success', msg: `Switched to ${newBranch}` });
                    refetchStatus(); // Refresh parent
                } catch (e) {
                    setActionStatus({ type: 'error', msg: e.message });
                }
            };
            return (
                <div className="flex items-center space-x-2">
                    <span className="font-semibold text-gray-700">Current Branch:</span>
                    <select value={status.currentBranch} onChange={handleSwitch} disabled={isLoading} className="px-3 py-1 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        {status.allBranches.map(branch => <option key={branch} value={branch}>{branch}</option>)}
                    </select>
                    {isLoading && <span className="text-sm text-gray-500">Switching...</span>}
                    {actionStatus && <span className={`text-sm ${actionStatus.type === 'error' ? 'text-red-600' : 'text-green-600'}`}>{actionStatus.msg}</span>}
                </div>
            );
        };
        
        // --- RemoteEditor now uses useGit ---
        const RemoteEditor = ({ remote }) => {
            const { status, refetchStatus } = useGit();
            const [isEditing, setIsEditing] = useState(false);
            const [url, setUrl] = useState(remote.url);
            const [actionStatus, setActionStatus] = useState(null);
            
            const updateRpc = useRpc();
            const deleteRpc = useRpc();
            const pushRpc = useRpc();

            useEffect(() => {
                if (actionStatus) {
                    const timer = setTimeout(() => setActionStatus(null), 3000);
                    return () => clearTimeout(timer);
                }
            }, [actionStatus]);

            const handleSave = async () => { /* ... */ };
            const handleDelete = async () => {
                if (!window.confirm(`Are you sure you want to delete remote '${remote.name}'?`)) return;
                await deleteRpc.execute("GIT_DELETE_REMOTE", { remoteName: remote.name });
                refetchStatus(); // Refresh global state
            };
            const handlePush = async () => {
                try {
                    await pushRpc.execute("GIT_PUSH", { remoteName: remote.name, branchName: status.currentBranch });
                    setActionStatus({ type: 'success', msg: `Successfully pushed to ${remote.name}` });
                    // NOTE: A push action should trigger a log refresh. We'll address this.
                } catch(e) {
                    setActionStatus({ type: 'error', msg: e.message });
                }
            };

            const isLoading = updateRpc.isLoading || deleteRpc.isLoading || pushRpc.isLoading;
            // ... The rest of the JSX for RemoteEditor remains the same ...
            return (
                <div className="bg-gray-50 p-2 rounded border border-gray-200">
                    <div className="flex items-center space-x-3">
                        <span className="font-mono text-sm font-bold w-24 truncate" title={remote.name}>{remote.name}</span>
                        {isEditing ? (
                            <input type="text" value={url} onChange={e => setUrl(e.target.value)} className="flex-grow px-2 py-1 border border-gray-300 rounded-md text-sm" />
                        ) : (
                            <span className="font-mono text-sm text-gray-600 flex-grow truncate" title={remote.url}>{remote.url}</span>
                        )}
                        <div className="flex items-center space-x-2 flex-shrink-0">
                            {isEditing ? (
                                <><button onClick={handleSave} disabled={isLoading} className="text-sm text-green-600 hover:text-green-800 disabled:text-gray-400">Save</button><button onClick={() => { setIsEditing(false); setActionStatus(null); }} className="text-sm text-gray-500 hover:text-gray-700">Cancel</button></>
                            ) : (
                                <><button onClick={handlePush} disabled={isLoading} title={`Push ${status.currentBranch} to ${remote.name}`} className="text-sm text-indigo-600 hover:text-indigo-800 disabled:text-gray-400">Push</button><button onClick={() => setIsEditing(true)} className="text-sm text-blue-600 hover:text-blue-800">Edit</button><button onClick={handleDelete} disabled={isLoading} className="text-sm text-red-600 hover:text-red-800 disabled:text-gray-400">Delete</button></>
                            )}
                        </div>
                    </div>
                    {(actionStatus || pushRpc.isLoading) && (
                        <div className="mt-2 text-xs text-center">
                            {pushRpc.isLoading && <span className="text-blue-600">Pushing to {remote.name}...</span>}
                            {actionStatus && <span className={actionStatus.type === 'error' ? 'text-red-600' : 'text-green-600'}>{actionStatus.msg}</span>}
                        </div>
                    )}
                </div>
            );
        };
        
        // --- AddRemoteForm now uses useGit ---
        const AddRemoteForm = ({ onCancel }) => {
            const [name, setName] = useState('');
            const [url, setUrl] = useState('');
            const { execute, isLoading, error } = useRpc();
            const { refetchStatus } = useGit();

            const handleAdd = async () => {
                if (!name.trim() || !url.trim()) return;
                try {
                    await execute("GIT_ADD_REMOTE", { name, url });
                    refetchStatus(); // Refetch global state
                    onCancel(); // Close form
                } catch (e) { /* error is handled by hook */ }
            };
            // ... The rest of the JSX for AddRemoteForm remains the same ...
            return (
                <div className="p-3 bg-blue-50 border border-blue-200 rounded-lg mt-2 space-y-2">
                    <h4 className="font-semibold text-gray-700">Add New Remote</h4>
                    <Alert message={error} />
                    <div className="flex items-center space-x-2">
                        <input type="text" value={name} onChange={e => setName(e.target.value)} placeholder="Remote Name (e.g., origin)" className="w-1/3 px-2 py-1 border border-gray-300 rounded-md text-sm" disabled={isLoading} />
                        <input type="text" value={url} onChange={e => setUrl(e.target.value)} placeholder="Remote URL" className="flex-grow px-2 py-1 border border-gray-300 rounded-md text-sm" disabled={isLoading} />
                    </div>
                    <div className="flex justify-end space-x-2">
                        <button onClick={onCancel} className="text-sm text-gray-600 hover:text-gray-800">Cancel</button>
                        <button onClick={handleAdd} disabled={isLoading} className="px-3 py-1 bg-blue-600 text-white text-sm font-semibold rounded-md hover:bg-blue-700 disabled:bg-blue-300">
                            {isLoading ? 'Adding...' : 'Add Remote'}
                        </button>
                    </div>
                </div>
            );
        };

        // --- EnhancedGitLogView is now much simpler by using the new hook ---
        const EnhancedGitLogView = () => {
            const { isLoading, isLoadingMore, error, items: commits, hasMore, loadMore } = usePaginatedRpc("GET_GIT_LOG");

            const renderContent = () => {
                if (isLoading) return <p className="text-gray-500 text-center p-4">Loading commit history...</p>;
                if (error && commits.length === 0) return <Alert message={error} />;
                if (commits.length === 0) return <p className="text-gray-500 text-center p-4">No commits found.</p>;

                return (
                    <div className="space-y-4">
                        {commits.map((commit, index) => (
                            <div key={`${commit.sha}-${index}`} className="bg-white border border-gray-200 p-4 rounded-lg shadow-sm">
                                <div className="flex justify-between items-start">
                                    <p className="text-sm font-mono text-gray-500" title={commit.sha}>{commit.sha.substring(0, 10)}</p>
                                    <p className="text-sm text-gray-500">{new Date(commit.date).toLocaleString()}</p>
                                </div>
                                <h4 className="text-md font-semibold text-gray-800 my-1">{commit.message}</h4>
                                <p className="text-sm text-gray-600">by <span className="font-medium">{commit.author}</span></p>
                                {commit.mx_metadata && (
                                    <div className="mt-3 pt-3 border-t border-gray-200">
                                        <h5 className="text-sm font-semibold text-gray-500 mb-1">Mendix Metadata:</h5>
                                        <pre className="bg-gray-50 p-3 rounded-md text-xs text-gray-700 overflow-x-auto">{JSON.stringify(commit.mx_metadata, null, 2)}</pre>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                );
            };

            return (
                <div className="border-t border-gray-200 mt-4 pt-4">
                    <h2 className="text-xl font-semibold text-gray-700 mb-4">Commit History</h2>
                    {renderContent()}
                    <div className="mt-6 text-center">
                        {hasMore && (
                            <button onClick={loadMore} disabled={isLoadingMore} className="px-4 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 disabled:bg-blue-300">
                                {isLoadingMore ? 'Loading More...' : 'Load More'}
                            </button>
                        )}
                        {error && commits.length > 0 && <Alert message={error} />}
                        {!hasMore && commits.length > 0 && <p className="text-gray-500">End of commit history.</p>}
                    </div>
                </div>
            );
        };
        
        // --- GitRepoView now uses context, no props needed ---
        const GitRepoView = () => {
            const { status } = useGit();
            const [isAddingRemote, setIsAddingRemote] = useState(false);

            if (status.error) {
                return <Alert message={`An error occurred in the repository: ${status.error}`} />;
            }

            return (
                <div>
                    <div className="p-4 bg-white border border-gray-200 rounded-lg shadow-sm mb-6 space-y-3">
                        <h2 className="text-xl font-semibold text-gray-700">Repository Status</h2>
                        <BranchSelector />
                        <div>
                            <div className="flex justify-between items-center">
                                <span className="font-semibold text-gray-700">Remotes:</span>
                                {!isAddingRemote && (
                                    <button onClick={() => setIsAddingRemote(true)} className="px-2 py-1 bg-gray-200 text-gray-700 text-xs font-semibold rounded hover:bg-gray-300">
                                        + Add Remote
                                    </button>
                                )}
                            </div>
                            {status.remotes.length > 0 ? (
                                <div className="mt-1 space-y-2">
                                    {status.remotes.map(remote => <RemoteEditor key={remote.name} remote={remote} />)}
                                </div>
                            ) : !isAddingRemote && <p className="text-sm text-gray-500 mt-1">No remotes configured.</p>}

                            {isAddingRemote && <AddRemoteForm onCancel={() => setIsAddingRemote(false)} />}
                        </div>
                    </div>
                    <EnhancedGitLogView />
                </div>
            );
        };

        // --- NEW: Orchestrator component to handle loading/error/state logic ---
        const GitStatusOrchestrator = () => {
            const { isLoading, error, isRepo, refetchStatus } = useGit();
            
            useEffect(() => {
                refetchStatus();
            }, [refetchStatus]); // Initial fetch

            if (isLoading) {
                return <p className="text-center text-gray-500 p-8">Loading Git status...</p>;
            }
            if (error) {
                return <Alert message={`Failed to get Git status: ${error}`} />;
            }
            if (isRepo === false) { // Explicit check for boolean false
                return <GitInitView />;
            }
            if (isRepo === true) {
                return <GitRepoView />;
            }
            return null; // Render nothing while status is not yet determined
        };

        // --- REFACTORED: GitManagementView now just provides the context ---
        const GitManagementView = () => {
            return (
                <GitProvider>
                    <GitStatusOrchestrator />
                </GitProvider>
            );
        };

        // ===================================================================
        // 5. MAIN APP & IOC CONFIGURATION (No changes needed)
        // ===================================================================
        const App = () => {
            const viewManager = useDependency(ViewManagementService);
            return (
                <div className="p-4 max-w-4xl mx-auto bg-gray-50 shadow-lg rounded-lg mt-8">
                    <h1 className="text-3xl font-bold text-gray-800 mb-6 text-center">
                        Mendix Backend Control Panel
                    </h1>
                    {viewManager.getViews().map((ViewComponent, index) => (
                        <Fragment key={index}>
                            <ViewComponent />
                        </Fragment>
                    ))}
                </div>
            );
        };

        const AppWithDependencies = connectDependencies(App, [
            [ViewManagementService],
            [IMessageService, { useClass: BrowserMessageService }],
            [IView, { useValue: GitManagementView }], // Uses the new, clean view
        ]);

        const root = ReactDOM.createRoot(document.getElementById("app"));
        root.render(<AppWithDependencies />);
    </script>
</body>
</html>