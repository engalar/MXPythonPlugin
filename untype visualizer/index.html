<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Mendix Model Browser (RxJS Refactor)</title>
  <script src="assets/tailwindcss.js"></script>
  <style>
    .copy-icon {
      opacity: 0.2;
      transition: opacity 0.2s;
      cursor: pointer;
    }

    .group-hover:hover .copy-icon,
    .copy-icon:hover {
      opacity: 1;
    }

    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 120px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px 0;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -60px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .tooltip .tooltiptext::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #555 transparent transparent transparent;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
  </style>
</head>

<body class="bg-gray-100 font-sans text-sm">
  <div id="app"></div>

  <script src="assets/babel.min.js"></script>
  <script type="text/babel">
    const { React, ReactDOM, redi, rediReact, rxjs } = globalThis.__tmp;
    delete globalThis.__tmp;

    const { Inject, Injector, Many, setDependencies, createIdentifier } = redi;
    const { RediProvider, connectDependencies, useDependency, useInjector, useUpdateBinder } = rediReact;
    const { useState, useEffect, useCallback, useMemo, useRef, Fragment } = React;
    const { Subject } = rxjs; // Import Subject from RxJS

    // ===================================================================
    // 1. SERVICES (Separated Concerns: Communication & State)
    // ===================================================================

    // 1.1. COMMUNICATION SERVICE (Concern: Backend RPC) - Unchanged
    const IMendixRpcClient = createIdentifier('IMendixRpcClient');
    class MendixRpcClient {
      constructor() {
        this.requestId = 0;
        this.pendingRequests = new Map();
        window.addEventListener('message', this.handleResponse);
      }
      handleResponse = (event) => {
        if (event.data.type !== 'backendResponse') return;
        const data = typeof event.data.data === 'string' ? JSON.parse(event.data.data) : event.data.data;
        const pendingRequest = this.pendingRequests.get(data.requestId);
        if (pendingRequest) {
          this.pendingRequests.delete(data.requestId);
          if (data.error) pendingRequest.reject(new Error(data.error.message || data.error));
          else pendingRequest.resolve(data.result);
        }
      }
      call(method, params = {}) {
        const requestId = ++this.requestId;
        return new Promise((resolve, reject) => {
          this.pendingRequests.set(requestId, { resolve, reject });
          window.parent.sendMessage("frontend:message", { jsonrpc: "2.0", method, params, id: requestId });
        });
      }
      getNodeChildren(nodeId) { return this.call('getNodeChildren', { nodeId }); }
      getNodeDetails(nodeId) { return this.call('getNodeDetails', { nodeId }); }
      getPropertyChildren(propertyId) { return this.call('getPropertyChildren', { propertyId }); }
      dispose() { window.removeEventListener('message', this.handleResponse); }
    }

    // 1.2. STATE MANAGEMENT SERVICE (Concern: Application State) - Refactored with RxJS
    class AppState {
      // Use a private RxJS Subject to broadcast updates.
      #update$ = new Subject();

      constructor(rpcClient) {
        this.rpcClient = rpcClient;
        this.rootNodes = [];
        this.selectedNode = null;
        this.isDetailsLoading = false;
        this.loadRootNodes();
      }

      // Expose the subject as an Observable for components to subscribe to.
      // This prevents external code from calling .next() on our subject.
      get updates() {
        return this.#update$.asObservable();
      }

      async loadRootNodes() {
        this.rootNodes = await this.rpcClient.getNodeChildren('root');
        this.#update$.next(); // Broadcast that state has changed
      }

      async selectNode(nodeInfo) {
        if (this.selectedNode && nodeInfo.id === this.selectedNode.id) return;

        this.isDetailsLoading = true;
        this.selectedNode = { id: nodeInfo.id, path: nodeInfo.path, details: null };
        this.#update$.next(); // Broadcast loading state change

        try {
          const details = await this.rpcClient.getNodeDetails(nodeInfo.id);
          if (this.selectedNode && this.selectedNode.id === nodeInfo.id) {
            this.selectedNode.details = details;
          }
        } catch (e) {
          alert(`Error getting details: ${e.message}`);
          this.selectedNode = null;
        } finally {
          this.isDetailsLoading = false;
          this.#update$.next(); // Broadcast final state change
        }
      }
    }
    setDependencies(AppState, [IMendixRpcClient]);


    // ===================================================================
    // 2. UI COMPONENTS (Correctly using useUpdateBinder)
    // ===================================================================

    // --- Helper Components (Largely Unchanged) ---
    function copyToClipboard(text, tooltipRef) {
      navigator.clipboard.writeText(text).then(() => {
        if (tooltipRef && tooltipRef.current) {
          const originalText = tooltipRef.current.innerText;
          tooltipRef.current.innerText = 'Copied!';
          setTimeout(() => { tooltipRef.current.innerText = originalText; }, 1500);
        }
      }).catch(err => console.error('Failed to copy: ', err));
    }

    function CopyButton({ textToCopy, tooltipText = "Copy path" }) {
      const tooltipRef = useRef(null);
      return (
        <div className="tooltip" onClick={(e) => { e.stopPropagation(); copyToClipboard(textToCopy, tooltipRef); }}>
          <span className="copy-icon ml-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
          </span>
          <span className="tooltiptext" ref={tooltipRef}>{tooltipText}</span>
        </div>
      );
    }

    function CollapsibleSection({ title, count, children, defaultOpen = false, path }) {
      const [isOpen, setIsOpen] = useState(defaultOpen);
      return (
        <div className="mb-4">
          <h3 onClick={() => setIsOpen(!isOpen)} className="group-hover font-semibold text-gray-700 border-b pb-1 mb-2 cursor-pointer flex justify-between items-center select-none">
            <span className="flex items-center">{title} ({count}) {path && <CopyButton textToCopy={path} />}</span>
            <span className="text-gray-500 text-xs transform transition-transform">{isOpen ? '▼' : '►'}</span>
          </h3>
          {isOpen && children}
        </div>
      );
    }

    // --- Core Components Refactored ---

    function PropertyNode({ node, level = 0, parentPath = '' }) {
      const [isExpanded, setIsExpanded] = useState(false);
      const [children, setChildren] = useState([]);
      const [isLoading, setIsLoading] = useState(false);
      const rpcClient = useDependency(IMendixRpcClient); // Injected dependency

      const handleToggle = async () => {
        if (!node.hasChildren) return;
        const nextExpandedState = !isExpanded;
        setIsExpanded(nextExpandedState);
        if (nextExpandedState && children.length === 0) {
          setIsLoading(true);
          try {
            setChildren(await rpcClient.getPropertyChildren(node.id));
          } catch (e) {
            alert(`Error fetching property children: ${e.message}`);
            setIsExpanded(false);
          } finally {
            setIsLoading(false);
          }
        }
      };
      const currentPath = useMemo(() => node.name.startsWith('[') ? `${parentPath}${node.name}` : `${parentPath}['${node.name}']`, [parentPath, node.name]);

      return (
        <div className="border-b hover:bg-gray-50 text-xs">
          <div className="group-hover flex items-center" style={{ paddingLeft: `${level * 16}px` }} onClick={handleToggle}>
            <div className={`p-1 flex items-center flex-grow ${node.hasChildren ? 'cursor-pointer' : ''}`}>
              <span className="w-5 h-5 text-center text-gray-500 mr-1 flex-shrink-0">{node.hasChildren ? (isExpanded ? '▼' : '►') : <span className="inline-block w-3"></span>}</span>
              <span className="font-mono text-gray-600 break-all w-2/5 pr-2">{node.name}</span>
              <span className={`break-all w-2/5 pr-2 ${node.valueType === 'ResolvableElement' ? 'italic text-purple-700' : ''}`}>{node.value}</span>
              <span className="text-gray-500 break-all w-1/5">{node.type}</span>
            </div>
            <CopyButton textToCopy={currentPath} />
          </div>
          {isExpanded && (
            <div>
              {isLoading && <div style={{ paddingLeft: `${(level + 1) * 16}px` }} className="text-gray-400 italic p-1">Loading...</div>}
              {children.map(child => <PropertyNode key={child.id} node={child} level={level + 1} parentPath={currentPath} />)}
            </div>
          )}
        </div>
      );
    }

    function InspectorPanel() {
      const appState = useDependency(AppState);
      // CORRECT: useUpdateBinder now receives a real RxJS Observable.
      useUpdateBinder(appState.updates);

      const { selectedNode, isDetailsLoading } = appState;
      if (isDetailsLoading) return <div className="p-4 text-gray-500">Loading details...</div>;
      if (!selectedNode || !selectedNode.details) return <div className="p-4 text-gray-500">Select a unit to see its details.</div>;

      const { details } = selectedNode;
      const { name, type, properties, elements } = details;
      const groupedElements = elements.reduce((acc, el) => { (acc[el.type] = acc[el.type] || []).push(el); return acc; }, {});

      return (
        <div className="p-3 bg-white h-full overflow-y-auto">
          <h2 className="text-lg font-bold text-gray-800 break-all">{name}</h2>
          <p className="text-xs text-blue-600 bg-blue-100 rounded px-2 py-0.5 inline-block mb-4">{type}</p>
          <CollapsibleSection title="Internal Elements" count={elements.length} defaultOpen={false}>
            {elements.length > 0 ? (
              Object.entries(groupedElements).map(([elementType, elementList]) => {
                const groupPath = `@${elementType}`;
                return (
                  <CollapsibleSection key={elementType} title={elementType} count={elementList.length} path={groupPath}>
                    {elementList.map((el) => {
                      const hasName = el.name && !el.name.startsWith('[');
                      const elIdentifier = hasName ? `[Name='${el.name}']` : `[${el.name.replace(/[\[\]]/g, '')}]`;
                      return <PropertyNode key={el.id} node={el} level={1} parentPath={`${groupPath}${elIdentifier}`} />;
                    })}
                  </CollapsibleSection>
                );
              })
            ) : <p className="text-xs text-gray-400 italic">No internal elements found.</p>}
          </CollapsibleSection>
          <CollapsibleSection title="Properties" count={properties.length} defaultOpen={true}>
            {properties.length > 0 ? (
              <div className="w-full text-left text-xs">
                <div className="border-b border-t flex bg-gray-50 sticky top-0">
                  <div className="font-semibold p-1 w-2/5 pl-8">Name</div>
                  <div className="font-semibold p-1 w-2/5">Value</div>
                  <div className="font-semibold p-1 w-1/5">Type</div>
                </div>
                <div>{properties.map(prop => <PropertyNode key={prop.id} node={prop} parentPath="@" />)}</div>
              </div>
            ) : <p className="text-xs text-gray-400 italic">No properties found.</p>}
          </CollapsibleSection>
        </div>
      );
    }

    function TreeNode({ node, level = 0, parentPath = '' }) {
      const [isExpanded, setIsExpanded] = useState(false);
      const [children, setChildren] = useState([]);
      const [isLoading, setIsLoading] = useState(false);
      const rpcClient = useDependency(IMendixRpcClient);
      const appState = useDependency(AppState);

      // CORRECT: This component will now re-render when the selected node changes.
      useUpdateBinder(appState.updates);

      const { selectedNode } = appState;
      const currentPath = useMemo(() => `${parentPath}/${node.type}[Name='${node.name}']`, [node, parentPath]);

      const handleToggle = async () => {
        const nextExpandedState = !isExpanded;
        setIsExpanded(nextExpandedState);
        if (nextExpandedState && children.length === 0 && node.hasChildren) {
          setIsLoading(true);
          try {
            setChildren(await rpcClient.getNodeChildren(node.id));
          } catch (e) {
            alert(`Error fetching children: ${e.message}`);
            setIsExpanded(false);
          } finally {
            setIsLoading(false);
          }
        }
      };

      const isSelected = selectedNode?.id === node.id;
      const handleSelect = () => appState.selectNode({ id: node.id, path: currentPath });

      return (
        <div style={{ paddingLeft: `${level * 16}px` }}>
          <div onClick={handleSelect} className={`group-hover flex items-center p-1 rounded cursor-pointer ${isSelected ? 'bg-blue-200' : 'hover:bg-gray-200'}`}>
            <button onClick={(e) => { e.stopPropagation(); handleToggle(); }} className="w-5 h-5 text-center text-gray-500 mr-1 flex-shrink-0" disabled={!node.hasChildren}>
              {node.hasChildren ? (isExpanded ? '▼' : '►') : <span className="inline-block w-2"></span>}
            </button>
            <div className="flex-grow overflow-hidden flex items-center">
              <span className="font-semibold truncate">{node.name}</span>
              <span className={`ml-2 text-xs truncate ${node.isUnit ? "text-blue-700" : "text-gray-600"}`}>({node.type})</span>
            </div>
            <CopyButton textToCopy={currentPath} />
          </div>
          {isExpanded && (
            <div>
              {isLoading && <div style={{ paddingLeft: `16px` }} className="text-gray-400 italic">Loading...</div>}
              {children.map(child => <TreeNode key={child.id} node={child} level={level + 1} parentPath={currentPath} />)}
            </div>
          )}
        </div>
      );
    }

    function TreeView() {
      const appState = useDependency(AppState);
      // CORRECT: This component will re-render when the rootNodes are loaded.
      useUpdateBinder(appState.updates);

      return (
        <div className="w-1/3 h-full border-r bg-white overflow-y-auto p-2">
          <h1 className="text-xl font-bold p-2">Mendix Model Browser</h1>
          {appState.rootNodes.map(node => (
            <TreeNode key={node.id} node={node} parentPath="/" />
          ))}
        </div>
      );
    }

    // ===================================================================
    // 3. THE MAIN APP COMPONENT (THE "SHELL")
    // ===================================================================
    const App = () => {
      return (
        <div className="flex h-screen w-screen text-gray-800">
          <TreeView />
          <div className="w-2/3 h-full overflow-hidden">
            <InspectorPanel />
          </div>
        </div>
      );
    };

    // ===============================================================
    // 4. IOC CONTAINER CONFIGURATION & APP ROOT
    // ===============================================================
    const AppWithDependencies = connectDependencies(App, [
      [IMendixRpcClient, { useClass: MendixRpcClient }],
      [AppState],
    ]);

    const root = ReactDOM.createRoot(document.getElementById('app'));
    root.render(<AppWithDependencies />);
  </script>
  <script type="module">
    import * as React from "https://esm.sh/react";
    import ReactDOM from "https://esm.sh/react-dom/client";
    import * as redi from "https://esm.sh/@wendellhu/redi";
    import * as rediReact from "https://esm.sh/@wendellhu/redi/react-bindings";
    import * as rxjs from "https://esm.sh/rxjs"; // <-- Added RxJS import
    window.__tmp = { React, ReactDOM, redi, rediReact, rxjs }; // <-- Made RxJS available to the babel script
  </script>
</body>

</html>